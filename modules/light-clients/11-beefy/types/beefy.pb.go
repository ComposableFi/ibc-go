// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ibc/lightclients/beefy/v1/beefy.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/protobuf/types/known/durationpb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Partial data for MmrLeaf
type MmrLeafPartial struct {
	// todo: this should be uint8 :(
	Version uint8 `protobuf:"varint,1,opt,name=version,proto3,customtype=uint8" json:"version"`
	// parent block for this leaf
	ParentNumber uint64 `protobuf:"varint,2,opt,name=parent_number,json=parentNumber,proto3" json:"parent_number,omitempty"`
	// parent hash for this leaf
	ParentHash []byte `protobuf:"bytes,3,opt,name=parent_hash,json=parentHash,proto3" json:"parent_hash,omitempty"`
	// next authority set.
	NextAuthoritySet BeefyAuthoritySet `protobuf:"bytes,4,opt,name=next_authority_set,json=nextAuthoritySet,proto3" json:"next_authority_set"`
}

func (m *MmrLeafPartial) Reset()         { *m = MmrLeafPartial{} }
func (m *MmrLeafPartial) String() string { return proto.CompactTextString(m) }
func (*MmrLeafPartial) ProtoMessage()    {}
func (*MmrLeafPartial) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{0}
}
func (m *MmrLeafPartial) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MmrLeafPartial) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MmrLeafPartial.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MmrLeafPartial) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MmrLeafPartial.Merge(m, src)
}
func (m *MmrLeafPartial) XXX_Size() int {
	return m.Size()
}
func (m *MmrLeafPartial) XXX_DiscardUnknown() {
	xxx_messageInfo_MmrLeafPartial.DiscardUnknown(m)
}

var xxx_messageInfo_MmrLeafPartial proto.InternalMessageInfo

func (m *MmrLeafPartial) GetParentNumber() uint64 {
	if m != nil {
		return m.ParentNumber
	}
	return 0
}

func (m *MmrLeafPartial) GetParentHash() []byte {
	if m != nil {
		return m.ParentHash
	}
	return nil
}

func (m *MmrLeafPartial) GetNextAuthoritySet() BeefyAuthoritySet {
	if m != nil {
		return m.NextAuthoritySet
	}
	return BeefyAuthoritySet{}
}

// Beefy Authority Info
type BeefyAuthoritySet struct {
	// Id of the authority set, it should be strictly increasing
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// size  of the authority set
	Len uint64 `protobuf:"varint,2,opt,name=len,proto3" json:"len,omitempty"`
	// merkle root of all authority public keys.
	AuthorityRoot []byte `protobuf:"bytes,3,opt,name=authority_root,json=authorityRoot,proto3" json:"authority_root,omitempty"`
}

func (m *BeefyAuthoritySet) Reset()         { *m = BeefyAuthoritySet{} }
func (m *BeefyAuthoritySet) String() string { return proto.CompactTextString(m) }
func (*BeefyAuthoritySet) ProtoMessage()    {}
func (*BeefyAuthoritySet) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{1}
}
func (m *BeefyAuthoritySet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BeefyAuthoritySet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BeefyAuthoritySet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BeefyAuthoritySet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BeefyAuthoritySet.Merge(m, src)
}
func (m *BeefyAuthoritySet) XXX_Size() int {
	return m.Size()
}
func (m *BeefyAuthoritySet) XXX_DiscardUnknown() {
	xxx_messageInfo_BeefyAuthoritySet.DiscardUnknown(m)
}

var xxx_messageInfo_BeefyAuthoritySet proto.InternalMessageInfo

func (m *BeefyAuthoritySet) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BeefyAuthoritySet) GetLen() uint64 {
	if m != nil {
		return m.Len
	}
	return 0
}

func (m *BeefyAuthoritySet) GetAuthorityRoot() []byte {
	if m != nil {
		return m.AuthorityRoot
	}
	return nil
}

// ClientState from Tendermint tracks the current validator set, latest height,
// and a possible frozen height.
type ClientState struct {
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Latest mmr root hash
	MmrRootHash []byte `protobuf:"bytes,3,opt,name=mmr_root_hash,json=mmrRootHash,proto3" json:"mmr_root_hash,omitempty"`
	// block number for the latest mmr_root_hash
	LatestBeefyHeight uint64 `protobuf:"varint,4,opt,name=latest_beefy_height,json=latestBeefyHeight,proto3" json:"latest_beefy_height,omitempty"`
	// authorities for the current round
	Authority *BeefyAuthoritySet `protobuf:"bytes,5,opt,name=authority,proto3" json:"authority,omitempty"`
}

func (m *ClientState) Reset()         { *m = ClientState{} }
func (m *ClientState) String() string { return proto.CompactTextString(m) }
func (*ClientState) ProtoMessage()    {}
func (*ClientState) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{2}
}
func (m *ClientState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientState.Merge(m, src)
}
func (m *ClientState) XXX_Size() int {
	return m.Size()
}
func (m *ClientState) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientState.DiscardUnknown(m)
}

var xxx_messageInfo_ClientState proto.InternalMessageInfo

// data needed to prove finality about ibc commitments in parachain
type ParachainHeaderProof struct {
	// leaf index, latest_beefy_block - beefy_activation_block
	LeafIndex uint64 `protobuf:"varint,1,opt,name=leaf_index,json=leafIndex,proto3" json:"leaf_index,omitempty"`
	// mmr proofs for this index, gotten from rpc "mmr_generateProofs"
	Proofs [][]byte `protobuf:"bytes,2,rep,name=proofs,proto3" json:"proofs,omitempty"`
	// proofs for our header in the parachain heads root
	HeadsProof [][]byte `protobuf:"bytes,4,rep,name=heads_proof,json=headsProof,proto3" json:"heads_proof,omitempty"`
	// reconstructed MmrLeaf, see beefy-go spec
	MmrLeafPartial *MmrLeafPartial `protobuf:"bytes,5,opt,name=mmr_leaf_partial,json=mmrLeafPartial,proto3" json:"mmr_leaf_partial,omitempty"`
}

func (m *ParachainHeaderProof) Reset()         { *m = ParachainHeaderProof{} }
func (m *ParachainHeaderProof) String() string { return proto.CompactTextString(m) }
func (*ParachainHeaderProof) ProtoMessage()    {}
func (*ParachainHeaderProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{3}
}
func (m *ParachainHeaderProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParachainHeaderProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParachainHeaderProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParachainHeaderProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParachainHeaderProof.Merge(m, src)
}
func (m *ParachainHeaderProof) XXX_Size() int {
	return m.Size()
}
func (m *ParachainHeaderProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ParachainHeaderProof.DiscardUnknown(m)
}

var xxx_messageInfo_ParachainHeaderProof proto.InternalMessageInfo

// data needed to update the client
type ClientUpdateProof struct {
	// new mmr_root_hash
	MmrRootHash []byte `protobuf:"bytes,1,opt,name=mmr_root_hash,json=mmrRootHash,proto3" json:"mmr_root_hash,omitempty"`
	// gotten from rpc subscription
	Signatures [][]byte `protobuf:"bytes,2,rep,name=signatures,proto3" json:"signatures,omitempty"`
	// generated using full authority list from runtime
	AuthorityProof [][]byte `protobuf:"bytes,3,rep,name=authority_proof,json=authorityProof,proto3" json:"authority_proof,omitempty"`
}

func (m *ClientUpdateProof) Reset()         { *m = ClientUpdateProof{} }
func (m *ClientUpdateProof) String() string { return proto.CompactTextString(m) }
func (*ClientUpdateProof) ProtoMessage()    {}
func (*ClientUpdateProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{4}
}
func (m *ClientUpdateProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientUpdateProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientUpdateProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientUpdateProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientUpdateProof.Merge(m, src)
}
func (m *ClientUpdateProof) XXX_Size() int {
	return m.Size()
}
func (m *ClientUpdateProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientUpdateProof.DiscardUnknown(m)
}

var xxx_messageInfo_ClientUpdateProof proto.InternalMessageInfo

// ConsensusState defines the consensus state from Tendermint.
type ConsensusState struct {
	// timestamp that corresponds to the block height in which the ConsensusState
	// was stored.
	Timestamp time.Time `protobuf:"bytes,1,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// commitment root (i.e app hash)
	Root []byte `protobuf:"bytes,2,opt,name=root,proto3" json:"root,omitempty"`
}

func (m *ConsensusState) Reset()         { *m = ConsensusState{} }
func (m *ConsensusState) String() string { return proto.CompactTextString(m) }
func (*ConsensusState) ProtoMessage()    {}
func (*ConsensusState) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{5}
}
func (m *ConsensusState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusState.Merge(m, src)
}
func (m *ConsensusState) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusState.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusState proto.InternalMessageInfo

// Misbehaviour is a wrapper over two conflicting Headers
// that implements Misbehaviour interface expected by ICS-02
type Misbehaviour struct {
	ClientId string  `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty" yaml:"client_id"`
	Header1  *Header `protobuf:"bytes,2,opt,name=header_1,json=header1,proto3" json:"header_1,omitempty" yaml:"header_1"`
	Header2  *Header `protobuf:"bytes,3,opt,name=header_2,json=header2,proto3" json:"header_2,omitempty" yaml:"header_2"`
}

func (m *Misbehaviour) Reset()         { *m = Misbehaviour{} }
func (m *Misbehaviour) String() string { return proto.CompactTextString(m) }
func (*Misbehaviour) ProtoMessage()    {}
func (*Misbehaviour) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{6}
}
func (m *Misbehaviour) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Misbehaviour) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Misbehaviour.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Misbehaviour) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Misbehaviour.Merge(m, src)
}
func (m *Misbehaviour) XXX_Size() int {
	return m.Size()
}
func (m *Misbehaviour) XXX_DiscardUnknown() {
	xxx_messageInfo_Misbehaviour.DiscardUnknown(m)
}

var xxx_messageInfo_Misbehaviour proto.InternalMessageInfo

// Header contains the neccessary data to proove finality about IBC commitments
type Header struct {
	// scale-encoded header bytes
	ParachainHeader []byte `protobuf:"bytes,1,opt,name=parachain_header,json=parachainHeader,proto3" json:"parachain_header,omitempty" yaml:"signed_header"`
	// merkle proof of inclusion in header.extrinsic_root
	ExtrinsicProof [][]byte `protobuf:"bytes,2,rep,name=extrinsic_proof,json=extrinsicProof,proto3" json:"extrinsic_proof,omitempty"`
	// actual scale encoded timestamp extrinsic.
	TimestampExtrinsic []byte `protobuf:"bytes,3,opt,name=timestamp_extrinsic,json=timestampExtrinsic,proto3" json:"timestamp_extrinsic,omitempty"`
	// Data needed to prove parachain header finality
	ParachainHeaderProof ParachainHeaderProof `protobuf:"bytes,4,opt,name=parachain_header_proof,json=parachainHeaderProof,proto3" json:"parachain_header_proof"`
	// optional payload to update the mmr root hash.
	ClientUpdateProof *ClientUpdateProof `protobuf:"bytes,5,opt,name=client_update_proof,json=clientUpdateProof,proto3" json:"client_update_proof,omitempty"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{7}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

func (m *Header) GetParachainHeader() []byte {
	if m != nil {
		return m.ParachainHeader
	}
	return nil
}

func (m *Header) GetExtrinsicProof() [][]byte {
	if m != nil {
		return m.ExtrinsicProof
	}
	return nil
}

func (m *Header) GetTimestampExtrinsic() []byte {
	if m != nil {
		return m.TimestampExtrinsic
	}
	return nil
}

func (m *Header) GetParachainHeaderProof() ParachainHeaderProof {
	if m != nil {
		return m.ParachainHeaderProof
	}
	return ParachainHeaderProof{}
}

func (m *Header) GetClientUpdateProof() *ClientUpdateProof {
	if m != nil {
		return m.ClientUpdateProof
	}
	return nil
}

func init() {
	proto.RegisterType((*MmrLeafPartial)(nil), "ibc.lightclients.beefy.v1.MmrLeafPartial")
	proto.RegisterType((*BeefyAuthoritySet)(nil), "ibc.lightclients.beefy.v1.BeefyAuthoritySet")
	proto.RegisterType((*ClientState)(nil), "ibc.lightclients.beefy.v1.ClientState")
	proto.RegisterType((*ParachainHeaderProof)(nil), "ibc.lightclients.beefy.v1.ParachainHeaderProof")
	proto.RegisterType((*ClientUpdateProof)(nil), "ibc.lightclients.beefy.v1.ClientUpdateProof")
	proto.RegisterType((*ConsensusState)(nil), "ibc.lightclients.beefy.v1.ConsensusState")
	proto.RegisterType((*Misbehaviour)(nil), "ibc.lightclients.beefy.v1.Misbehaviour")
	proto.RegisterType((*Header)(nil), "ibc.lightclients.beefy.v1.Header")
}

func init() {
	proto.RegisterFile("ibc/lightclients/beefy/v1/beefy.proto", fileDescriptor_43205c4bfbe9a422)
}

var fileDescriptor_43205c4bfbe9a422 = []byte{
	// 895 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0x4f, 0x6f, 0xe3, 0x44,
	0x14, 0x8f, 0xd3, 0x6c, 0xdb, 0xbc, 0x34, 0x69, 0x3a, 0x8d, 0x56, 0xd9, 0x4a, 0xc4, 0x21, 0x68,
	0xb5, 0x41, 0xa2, 0xb6, 0x92, 0xbd, 0xa0, 0x3d, 0x41, 0x2a, 0xa4, 0x16, 0xb1, 0xa8, 0x72, 0xe1,
	0xb2, 0x5a, 0xc9, 0x8c, 0xe3, 0x49, 0x3c, 0xc2, 0xf6, 0x58, 0x9e, 0x71, 0xd4, 0x9e, 0x91, 0x10,
	0xc7, 0xfd, 0x08, 0x7c, 0x9c, 0xe5, 0x82, 0xf6, 0x88, 0x38, 0x04, 0x68, 0xbf, 0x41, 0x4f, 0x1c,
	0x91, 0x67, 0xc6, 0x4e, 0xba, 0x59, 0xba, 0xda, 0xdb, 0x9b, 0xf7, 0xde, 0xfc, 0xe6, 0xfd, 0xf9,
	0xfd, 0x6c, 0x78, 0x4c, 0xbd, 0xa9, 0x1d, 0xd2, 0x79, 0x20, 0xa6, 0x21, 0x25, 0xb1, 0xe0, 0xb6,
	0x47, 0xc8, 0xec, 0xca, 0x5e, 0x8c, 0x94, 0x61, 0x25, 0x29, 0x13, 0x0c, 0x3d, 0xa2, 0xde, 0xd4,
	0x5a, 0x4f, 0xb3, 0x54, 0x74, 0x31, 0x3a, 0xea, 0xcd, 0x19, 0x9b, 0x87, 0xc4, 0x96, 0x89, 0x5e,
	0x36, 0xb3, 0xfd, 0x2c, 0xc5, 0x82, 0xb2, 0x58, 0x5d, 0x3d, 0x32, 0xdf, 0x8e, 0x0b, 0x1a, 0x11,
	0x2e, 0x70, 0x94, 0xe8, 0x84, 0xce, 0x9c, 0xcd, 0x99, 0x34, 0xed, 0xdc, 0x52, 0xde, 0xc1, 0x3f,
	0x06, 0xb4, 0x9e, 0x47, 0xe9, 0x37, 0x04, 0xcf, 0xce, 0x71, 0x2a, 0x28, 0x0e, 0xd1, 0x13, 0xd8,
	0x59, 0x90, 0x94, 0x53, 0x16, 0x77, 0x8d, 0xbe, 0x31, 0x6c, 0x4e, 0x9a, 0xaf, 0x97, 0x66, 0xe5,
	0xcf, 0xa5, 0xf9, 0x20, 0xa3, 0xb1, 0xf8, 0xdc, 0x29, 0xa2, 0xe8, 0x13, 0x68, 0x26, 0x38, 0x25,
	0xb1, 0x70, 0xe3, 0x2c, 0xf2, 0x48, 0xda, 0xad, 0xf6, 0x8d, 0x61, 0xcd, 0xd9, 0x53, 0xce, 0x6f,
	0xa5, 0x0f, 0x99, 0xd0, 0xd0, 0x49, 0x01, 0xe6, 0x41, 0x77, 0xab, 0x6f, 0x0c, 0xf7, 0x1c, 0x50,
	0xae, 0x53, 0xcc, 0x03, 0xf4, 0x03, 0xa0, 0x98, 0x5c, 0x0a, 0x17, 0x67, 0x22, 0x60, 0x29, 0x15,
	0x57, 0x2e, 0x27, 0xa2, 0x5b, 0xeb, 0x1b, 0xc3, 0xc6, 0xf8, 0x33, 0xeb, 0x7f, 0x07, 0x62, 0x4d,
	0x72, 0xe3, 0xcb, 0xe2, 0xd2, 0x05, 0x11, 0x93, 0x5a, 0x5e, 0xa7, 0xd3, 0xce, 0xd1, 0xd6, 0xfd,
	0x83, 0x97, 0x70, 0xb0, 0x91, 0x8c, 0x5a, 0x50, 0xa5, 0xbe, 0x6c, 0xb0, 0xe6, 0x54, 0xa9, 0x8f,
	0xda, 0xb0, 0x15, 0x92, 0x58, 0xb7, 0x90, 0x9b, 0xe8, 0x31, 0xb4, 0x56, 0x35, 0xa5, 0x8c, 0x09,
	0x5d, 0x7c, 0xb3, 0xf4, 0x3a, 0x8c, 0x89, 0xc1, 0xef, 0x06, 0x34, 0x4e, 0x64, 0x71, 0x17, 0x02,
	0x0b, 0x82, 0x1e, 0xc1, 0xee, 0x34, 0xc0, 0x34, 0x76, 0x35, 0x7c, 0xdd, 0xd9, 0x91, 0xe7, 0x33,
	0x1f, 0x0d, 0xa0, 0x19, 0x45, 0xa9, 0xc4, 0x5a, 0x9f, 0x46, 0x23, 0x8a, 0xd2, 0x1c, 0x4a, 0x8e,
	0xc3, 0x82, 0xc3, 0x10, 0x0b, 0xc2, 0x85, 0x2b, 0x3b, 0x75, 0x03, 0x92, 0x77, 0x2f, 0xe7, 0x51,
	0x73, 0x0e, 0x54, 0x48, 0x76, 0x73, 0x2a, 0x03, 0xe8, 0x6b, 0xa8, 0x97, 0xf5, 0x74, 0x1f, 0x7c,
	0xf8, 0xd4, 0x9c, 0xd5, 0xf5, 0x67, 0xb5, 0x5f, 0x7e, 0x35, 0x2b, 0x83, 0xdf, 0x0c, 0xe8, 0x9c,
	0xe3, 0x14, 0xcb, 0xaa, 0x4f, 0x09, 0xf6, 0x49, 0x7a, 0x9e, 0x32, 0x36, 0x43, 0x1f, 0x01, 0x84,
	0x04, 0xcf, 0x5c, 0x1a, 0xfb, 0xe4, 0x52, 0x8f, 0xae, 0x9e, 0x7b, 0xce, 0x72, 0x07, 0x7a, 0x08,
	0xdb, 0x49, 0x9e, 0xc7, 0xbb, 0xd5, 0xfe, 0xd6, 0x70, 0xcf, 0xd1, 0xa7, 0x9c, 0x01, 0x01, 0xc1,
	0x3e, 0x77, 0xe5, 0xb9, 0x5b, 0x93, 0x41, 0x90, 0x2e, 0x85, 0x7b, 0x01, 0xed, 0x7c, 0x2c, 0x12,
	0x3b, 0x51, 0x24, 0xd4, 0x9d, 0x7c, 0x7a, 0x4f, 0x27, 0x77, 0x59, 0xeb, 0xb4, 0xa2, 0x3b, 0x67,
	0xdd, 0xcb, 0xcf, 0x06, 0x1c, 0xa8, 0xe5, 0x7c, 0x9f, 0xf8, 0x58, 0x10, 0xf5, 0xe0, 0xc6, 0x1e,
	0x8c, 0xcd, 0x3d, 0xf4, 0x00, 0x38, 0x9d, 0xc7, 0x58, 0x64, 0x29, 0x29, 0x3a, 0x5a, 0xf3, 0xa0,
	0x27, 0xb0, 0xbf, 0x62, 0x87, 0xea, 0x6c, 0x4b, 0x26, 0xad, 0x48, 0x23, 0x1f, 0xd3, 0x85, 0xc4,
	0xd0, 0x3a, 0x61, 0x31, 0x27, 0x31, 0xcf, 0xb8, 0xe2, 0xc9, 0x04, 0xea, 0xa5, 0x44, 0x65, 0x01,
	0x8d, 0xf1, 0x91, 0xa5, 0x44, 0x6c, 0x15, 0x22, 0xb6, 0xbe, 0x2b, 0x32, 0x26, 0xbb, 0x39, 0xb9,
	0x5f, 0xfd, 0x65, 0x1a, 0xce, 0xea, 0x1a, 0x42, 0x50, 0x93, 0xc4, 0xac, 0xca, 0xfa, 0xa5, 0xad,
	0xdf, 0xfb, 0xa9, 0x0a, 0x7b, 0xcf, 0x29, 0xf7, 0x48, 0x80, 0x17, 0x94, 0x65, 0x29, 0x1a, 0x41,
	0x5d, 0x8d, 0xb0, 0xe4, 0xe5, 0xa4, 0x73, 0xbb, 0x34, 0xdb, 0x57, 0x38, 0x0a, 0x9f, 0x0d, 0xca,
	0xd0, 0xc0, 0xd9, 0x55, 0xf6, 0x99, 0x8f, 0x5e, 0xc2, 0x6e, 0x20, 0xd7, 0xef, 0x8e, 0xe4, 0x0b,
	0x8d, 0xf1, 0xc7, 0xf7, 0xec, 0x43, 0x31, 0x65, 0xd2, 0xbb, 0x5e, 0x9a, 0x3b, 0xca, 0x1e, 0xdd,
	0x2e, 0xcd, 0x7d, 0x85, 0x5f, 0xe0, 0x0c, 0x9c, 0x1d, 0x65, 0x8e, 0xd6, 0xd0, 0xc7, 0x52, 0x07,
	0x1f, 0x8a, 0x3e, 0xde, 0x40, 0x1f, 0x97, 0xe8, 0x63, 0x3d, 0x85, 0x7f, 0xab, 0xb0, 0xad, 0xb2,
	0xd1, 0x09, 0xb4, 0x93, 0x82, 0xd4, 0xae, 0xca, 0x52, 0x6b, 0x9f, 0x74, 0x6f, 0x97, 0x66, 0x47,
	0x01, 0xe5, 0xfb, 0x25, 0xbe, 0x0e, 0x0f, 0x9c, 0xfd, 0xe4, 0xae, 0x0c, 0xf2, 0xa5, 0x93, 0x4b,
	0x91, 0xd2, 0x98, 0xd3, 0xa9, 0x5e, 0xba, 0x62, 0x46, 0xab, 0x74, 0x2b, 0x86, 0xd9, 0x70, 0x58,
	0x6e, 0xc9, 0x2d, 0x63, 0x5a, 0xef, 0xa8, 0x0c, 0x7d, 0x55, 0x44, 0xd0, 0x8f, 0xf0, 0xf0, 0xed,
	0xf2, 0x4a, 0xbd, 0xe4, 0xb3, 0xb1, 0xef, 0x99, 0xcd, 0xbb, 0xc4, 0xaa, 0x3f, 0x86, 0x9d, 0xe4,
	0x5d, 0x42, 0xf6, 0xe0, 0x50, 0x2f, 0x3c, 0x93, 0xaa, 0xd0, 0x2f, 0xbd, 0xff, 0xeb, 0xb1, 0x21,
	0x25, 0xf9, 0x8c, 0xe1, 0x1c, 0x4c, 0x37, 0x02, 0x2f, 0x5e, 0x5f, 0xf7, 0x8c, 0x37, 0xd7, 0x3d,
	0xe3, 0xef, 0xeb, 0x9e, 0xf1, 0xea, 0xa6, 0x57, 0x79, 0x73, 0xd3, 0xab, 0xfc, 0x71, 0xd3, 0xab,
	0xbc, 0xf8, 0x62, 0x4e, 0x45, 0x90, 0x79, 0xd6, 0x94, 0x45, 0xf6, 0x94, 0xf1, 0x88, 0x71, 0x9b,
	0x7a, 0xd3, 0xe3, 0x39, 0xb3, 0x17, 0x4f, 0xed, 0x88, 0xf9, 0x59, 0x48, 0xb8, 0xfa, 0x57, 0x1e,
	0x17, 0x3f, 0xcb, 0xd1, 0xe8, 0x58, 0xfd, 0x2f, 0xc5, 0x55, 0x42, 0xb8, 0xb7, 0x2d, 0xf5, 0xf1,
	0xf4, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x86, 0x61, 0xee, 0xc4, 0x56, 0x07, 0x00, 0x00,
}

func (m *MmrLeafPartial) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MmrLeafPartial) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MmrLeafPartial) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.NextAuthoritySet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintBeefy(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.ParentHash) > 0 {
		i -= len(m.ParentHash)
		copy(dAtA[i:], m.ParentHash)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.ParentHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ParentNumber != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.ParentNumber))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BeefyAuthoritySet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeefyAuthoritySet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BeefyAuthoritySet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuthorityRoot) > 0 {
		i -= len(m.AuthorityRoot)
		copy(dAtA[i:], m.AuthorityRoot)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.AuthorityRoot)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Len != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.Len))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClientState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Authority != nil {
		{
			size, err := m.Authority.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.LatestBeefyHeight != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.LatestBeefyHeight))
		i--
		dAtA[i] = 0x20
	}
	if len(m.MmrRootHash) > 0 {
		i -= len(m.MmrRootHash)
		copy(dAtA[i:], m.MmrRootHash)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.MmrRootHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ParachainHeaderProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParachainHeaderProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParachainHeaderProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MmrLeafPartial != nil {
		{
			size, err := m.MmrLeafPartial.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.HeadsProof) > 0 {
		for iNdEx := len(m.HeadsProof) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.HeadsProof[iNdEx])
			copy(dAtA[i:], m.HeadsProof[iNdEx])
			i = encodeVarintBeefy(dAtA, i, uint64(len(m.HeadsProof[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Proofs) > 0 {
		for iNdEx := len(m.Proofs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Proofs[iNdEx])
			copy(dAtA[i:], m.Proofs[iNdEx])
			i = encodeVarintBeefy(dAtA, i, uint64(len(m.Proofs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.LeafIndex != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.LeafIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClientUpdateProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientUpdateProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientUpdateProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuthorityProof) > 0 {
		for iNdEx := len(m.AuthorityProof) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AuthorityProof[iNdEx])
			copy(dAtA[i:], m.AuthorityProof[iNdEx])
			i = encodeVarintBeefy(dAtA, i, uint64(len(m.AuthorityProof[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Signatures[iNdEx])
			copy(dAtA[i:], m.Signatures[iNdEx])
			i = encodeVarintBeefy(dAtA, i, uint64(len(m.Signatures[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MmrRootHash) > 0 {
		i -= len(m.MmrRootHash)
		copy(dAtA[i:], m.MmrRootHash)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.MmrRootHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0x12
	}
	n4, err4 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintBeefy(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Misbehaviour) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Misbehaviour) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Misbehaviour) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Header2 != nil {
		{
			size, err := m.Header2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Header1 != nil {
		{
			size, err := m.Header1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClientUpdateProof != nil {
		{
			size, err := m.ClientUpdateProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	{
		size, err := m.ParachainHeaderProof.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintBeefy(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.TimestampExtrinsic) > 0 {
		i -= len(m.TimestampExtrinsic)
		copy(dAtA[i:], m.TimestampExtrinsic)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.TimestampExtrinsic)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ExtrinsicProof) > 0 {
		for iNdEx := len(m.ExtrinsicProof) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExtrinsicProof[iNdEx])
			copy(dAtA[i:], m.ExtrinsicProof[iNdEx])
			i = encodeVarintBeefy(dAtA, i, uint64(len(m.ExtrinsicProof[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ParachainHeader) > 0 {
		i -= len(m.ParachainHeader)
		copy(dAtA[i:], m.ParachainHeader)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.ParachainHeader)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintBeefy(dAtA []byte, offset int, v uint64) int {
	offset -= sovBeefy(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MmrLeafPartial) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovBeefy(uint64(m.Version))
	}
	if m.ParentNumber != 0 {
		n += 1 + sovBeefy(uint64(m.ParentNumber))
	}
	l = len(m.ParentHash)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	l = m.NextAuthoritySet.Size()
	n += 1 + l + sovBeefy(uint64(l))
	return n
}

func (m *BeefyAuthoritySet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBeefy(uint64(m.Id))
	}
	if m.Len != 0 {
		n += 1 + sovBeefy(uint64(m.Len))
	}
	l = len(m.AuthorityRoot)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *ClientState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	l = len(m.MmrRootHash)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.LatestBeefyHeight != 0 {
		n += 1 + sovBeefy(uint64(m.LatestBeefyHeight))
	}
	if m.Authority != nil {
		l = m.Authority.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *ParachainHeaderProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeafIndex != 0 {
		n += 1 + sovBeefy(uint64(m.LeafIndex))
	}
	if len(m.Proofs) > 0 {
		for _, b := range m.Proofs {
			l = len(b)
			n += 1 + l + sovBeefy(uint64(l))
		}
	}
	if len(m.HeadsProof) > 0 {
		for _, b := range m.HeadsProof {
			l = len(b)
			n += 1 + l + sovBeefy(uint64(l))
		}
	}
	if m.MmrLeafPartial != nil {
		l = m.MmrLeafPartial.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *ClientUpdateProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MmrRootHash)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	if len(m.Signatures) > 0 {
		for _, b := range m.Signatures {
			l = len(b)
			n += 1 + l + sovBeefy(uint64(l))
		}
	}
	if len(m.AuthorityProof) > 0 {
		for _, b := range m.AuthorityProof {
			l = len(b)
			n += 1 + l + sovBeefy(uint64(l))
		}
	}
	return n
}

func (m *ConsensusState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovBeefy(uint64(l))
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *Misbehaviour) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.Header1 != nil {
		l = m.Header1.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.Header2 != nil {
		l = m.Header2.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ParachainHeader)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	if len(m.ExtrinsicProof) > 0 {
		for _, b := range m.ExtrinsicProof {
			l = len(b)
			n += 1 + l + sovBeefy(uint64(l))
		}
	}
	l = len(m.TimestampExtrinsic)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	l = m.ParachainHeaderProof.Size()
	n += 1 + l + sovBeefy(uint64(l))
	if m.ClientUpdateProof != nil {
		l = m.ClientUpdateProof.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func sovBeefy(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBeefy(x uint64) (n int) {
	return sovBeefy(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MmrLeafPartial) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MmrLeafPartial: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MmrLeafPartial: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint8(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentNumber", wireType)
			}
			m.ParentNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentHash = append(m.ParentHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ParentHash == nil {
				m.ParentHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextAuthoritySet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NextAuthoritySet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeefyAuthoritySet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeefyAuthoritySet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeefyAuthoritySet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorityRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorityRoot = append(m.AuthorityRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthorityRoot == nil {
				m.AuthorityRoot = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmrRootHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MmrRootHash = append(m.MmrRootHash[:0], dAtA[iNdEx:postIndex]...)
			if m.MmrRootHash == nil {
				m.MmrRootHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestBeefyHeight", wireType)
			}
			m.LatestBeefyHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestBeefyHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Authority == nil {
				m.Authority = &BeefyAuthoritySet{}
			}
			if err := m.Authority.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParachainHeaderProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParachainHeaderProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParachainHeaderProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafIndex", wireType)
			}
			m.LeafIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeafIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proofs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proofs = append(m.Proofs, make([]byte, postIndex-iNdEx))
			copy(m.Proofs[len(m.Proofs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadsProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadsProof = append(m.HeadsProof, make([]byte, postIndex-iNdEx))
			copy(m.HeadsProof[len(m.HeadsProof)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmrLeafPartial", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MmrLeafPartial == nil {
				m.MmrLeafPartial = &MmrLeafPartial{}
			}
			if err := m.MmrLeafPartial.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientUpdateProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientUpdateProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientUpdateProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmrRootHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MmrRootHash = append(m.MmrRootHash[:0], dAtA[iNdEx:postIndex]...)
			if m.MmrRootHash == nil {
				m.MmrRootHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, make([]byte, postIndex-iNdEx))
			copy(m.Signatures[len(m.Signatures)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorityProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorityProof = append(m.AuthorityProof, make([]byte, postIndex-iNdEx))
			copy(m.AuthorityProof[len(m.AuthorityProof)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = append(m.Root[:0], dAtA[iNdEx:postIndex]...)
			if m.Root == nil {
				m.Root = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Misbehaviour) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Misbehaviour: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Misbehaviour: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header1 == nil {
				m.Header1 = &Header{}
			}
			if err := m.Header1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header2 == nil {
				m.Header2 = &Header{}
			}
			if err := m.Header2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParachainHeader", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParachainHeader = append(m.ParachainHeader[:0], dAtA[iNdEx:postIndex]...)
			if m.ParachainHeader == nil {
				m.ParachainHeader = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtrinsicProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtrinsicProof = append(m.ExtrinsicProof, make([]byte, postIndex-iNdEx))
			copy(m.ExtrinsicProof[len(m.ExtrinsicProof)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampExtrinsic", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimestampExtrinsic = append(m.TimestampExtrinsic[:0], dAtA[iNdEx:postIndex]...)
			if m.TimestampExtrinsic == nil {
				m.TimestampExtrinsic = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParachainHeaderProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ParachainHeaderProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientUpdateProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientUpdateProof == nil {
				m.ClientUpdateProof = &ClientUpdateProof{}
			}
			if err := m.ClientUpdateProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBeefy(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBeefy
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBeefy
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBeefy
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBeefy        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBeefy          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBeefy = fmt.Errorf("proto: unexpected end of group")
)
