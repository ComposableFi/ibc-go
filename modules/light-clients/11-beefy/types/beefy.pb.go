// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ibc/lightclients/beefy/v1/beefy.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/protobuf/types/known/durationpb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Partial data for MmrLeaf
type MmrLeafPartial struct {
	// todo: this should be uint8 :(
	Version uint64 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	// parent block for this leaf
	ParentNumber uint64 `protobuf:"varint,2,opt,name=parent_number,json=parentNumber,proto3" json:"parent_number,omitempty"`
	// parent hash for this leaf
	ParentHash []byte `protobuf:"bytes,3,opt,name=parent_hash,json=parentHash,proto3" json:"parent_hash,omitempty"`
	// next authority set.
	NextAuthoritySet BeefyAuthoritySet `protobuf:"bytes,4,opt,name=next_authority_set,json=nextAuthoritySet,proto3" json:"next_authority_set"`
}

func (m *MmrLeafPartial) Reset()         { *m = MmrLeafPartial{} }
func (m *MmrLeafPartial) String() string { return proto.CompactTextString(m) }
func (*MmrLeafPartial) ProtoMessage()    {}
func (*MmrLeafPartial) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{0}
}
func (m *MmrLeafPartial) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MmrLeafPartial) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MmrLeafPartial.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MmrLeafPartial) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MmrLeafPartial.Merge(m, src)
}
func (m *MmrLeafPartial) XXX_Size() int {
	return m.Size()
}
func (m *MmrLeafPartial) XXX_DiscardUnknown() {
	xxx_messageInfo_MmrLeafPartial.DiscardUnknown(m)
}

var xxx_messageInfo_MmrLeafPartial proto.InternalMessageInfo

func (m *MmrLeafPartial) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *MmrLeafPartial) GetParentNumber() uint64 {
	if m != nil {
		return m.ParentNumber
	}
	return 0
}

func (m *MmrLeafPartial) GetParentHash() []byte {
	if m != nil {
		return m.ParentHash
	}
	return nil
}

func (m *MmrLeafPartial) GetNextAuthoritySet() BeefyAuthoritySet {
	if m != nil {
		return m.NextAuthoritySet
	}
	return BeefyAuthoritySet{}
}

// Beefy Authority Info
type BeefyAuthoritySet struct {
	// Id of the authority set, it should be strictly increasing
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// size  of the authority set
	Len uint64 `protobuf:"varint,2,opt,name=len,proto3" json:"len,omitempty"`
	// merkle root of all authority public keys.
	AuthorityMerkleRoot []byte `protobuf:"bytes,3,opt,name=authorityMerkleRoot,proto3" json:"authorityMerkleRoot,omitempty"`
}

func (m *BeefyAuthoritySet) Reset()         { *m = BeefyAuthoritySet{} }
func (m *BeefyAuthoritySet) String() string { return proto.CompactTextString(m) }
func (*BeefyAuthoritySet) ProtoMessage()    {}
func (*BeefyAuthoritySet) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{1}
}
func (m *BeefyAuthoritySet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BeefyAuthoritySet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BeefyAuthoritySet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BeefyAuthoritySet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BeefyAuthoritySet.Merge(m, src)
}
func (m *BeefyAuthoritySet) XXX_Size() int {
	return m.Size()
}
func (m *BeefyAuthoritySet) XXX_DiscardUnknown() {
	xxx_messageInfo_BeefyAuthoritySet.DiscardUnknown(m)
}

var xxx_messageInfo_BeefyAuthoritySet proto.InternalMessageInfo

func (m *BeefyAuthoritySet) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BeefyAuthoritySet) GetLen() uint64 {
	if m != nil {
		return m.Len
	}
	return 0
}

func (m *BeefyAuthoritySet) GetAuthorityMerkleRoot() []byte {
	if m != nil {
		return m.AuthorityMerkleRoot
	}
	return nil
}

// ClientState from Tendermint tracks the current validator set, latest height,
// and a possible frozen height.
type ClientState struct {
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Latest mmr root hash
	MmrRootHash []byte `protobuf:"bytes,3,opt,name=mmr_root_hash,json=mmrRootHash,proto3" json:"mmr_root_hash,omitempty"`
	// block number for the latest mmr_root_hash
	LatestBeefyHeight uint64 `protobuf:"varint,4,opt,name=latestBeefyHeight,proto3" json:"latestBeefyHeight,omitempty"`
	// authorities for the current round
	Authority *BeefyAuthoritySet `protobuf:"bytes,5,opt,name=authority,proto3" json:"authority,omitempty"`
}

func (m *ClientState) Reset()         { *m = ClientState{} }
func (m *ClientState) String() string { return proto.CompactTextString(m) }
func (*ClientState) ProtoMessage()    {}
func (*ClientState) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{2}
}
func (m *ClientState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientState.Merge(m, src)
}
func (m *ClientState) XXX_Size() int {
	return m.Size()
}
func (m *ClientState) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientState.DiscardUnknown(m)
}

var xxx_messageInfo_ClientState proto.InternalMessageInfo

// data needed to prove finality about ibc commitments in parachain
type ParachainHeaderProof struct {
	// leaf index, latest_beefy_block - beefy_activation_block
	LeafIndex uint64 `protobuf:"varint,1,opt,name=leaf_index,json=leafIndex,proto3" json:"leaf_index,omitempty"`
	// mmr proofs for this index, gotten from rpc "mmr_generateProofs"
	Proofs [][]byte `protobuf:"bytes,2,rep,name=proofs,proto3" json:"proofs,omitempty"`
	// proofs for our header in the parachain heads root
	HeadsProof [][]byte `protobuf:"bytes,4,rep,name=heads_proof,json=headsProof,proto3" json:"heads_proof,omitempty"`
	// reconstructed MmrLeaf, see beefy-go spec
	MmrLeafPartial *MmrLeafPartial `protobuf:"bytes,5,opt,name=mmr_leaf_partial,json=mmrLeafPartial,proto3" json:"mmr_leaf_partial,omitempty"`
}

func (m *ParachainHeaderProof) Reset()         { *m = ParachainHeaderProof{} }
func (m *ParachainHeaderProof) String() string { return proto.CompactTextString(m) }
func (*ParachainHeaderProof) ProtoMessage()    {}
func (*ParachainHeaderProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{3}
}
func (m *ParachainHeaderProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParachainHeaderProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParachainHeaderProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParachainHeaderProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParachainHeaderProof.Merge(m, src)
}
func (m *ParachainHeaderProof) XXX_Size() int {
	return m.Size()
}
func (m *ParachainHeaderProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ParachainHeaderProof.DiscardUnknown(m)
}

var xxx_messageInfo_ParachainHeaderProof proto.InternalMessageInfo

// data needed to update the client
type ClientUpdateProof struct {
	// new mmr_root_hash
	MmrRootHash []byte `protobuf:"bytes,1,opt,name=mmr_root_hash,json=mmrRootHash,proto3" json:"mmr_root_hash,omitempty"`
	// gotten from rpc subscription
	Signatures [][]byte `protobuf:"bytes,2,rep,name=signatures,proto3" json:"signatures,omitempty"`
	// generated using full authority list from runtime
	AuthorityProof [][]byte `protobuf:"bytes,3,rep,name=authority_proof,json=authorityProof,proto3" json:"authority_proof,omitempty"`
}

func (m *ClientUpdateProof) Reset()         { *m = ClientUpdateProof{} }
func (m *ClientUpdateProof) String() string { return proto.CompactTextString(m) }
func (*ClientUpdateProof) ProtoMessage()    {}
func (*ClientUpdateProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{4}
}
func (m *ClientUpdateProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientUpdateProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientUpdateProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientUpdateProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientUpdateProof.Merge(m, src)
}
func (m *ClientUpdateProof) XXX_Size() int {
	return m.Size()
}
func (m *ClientUpdateProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientUpdateProof.DiscardUnknown(m)
}

var xxx_messageInfo_ClientUpdateProof proto.InternalMessageInfo

// ConsensusState defines the consensus state from Tendermint.
type ConsensusState struct {
	// timestamp that corresponds to the block height in which the ConsensusState
	// was stored.
	Timestamp time.Time `protobuf:"bytes,1,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// commitment root (i.e app hash)
	Root []byte `protobuf:"bytes,2,opt,name=root,proto3" json:"root,omitempty"`
}

func (m *ConsensusState) Reset()         { *m = ConsensusState{} }
func (m *ConsensusState) String() string { return proto.CompactTextString(m) }
func (*ConsensusState) ProtoMessage()    {}
func (*ConsensusState) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{5}
}
func (m *ConsensusState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusState.Merge(m, src)
}
func (m *ConsensusState) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusState.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusState proto.InternalMessageInfo

// Misbehaviour is a wrapper over two conflicting Headers
// that implements Misbehaviour interface expected by ICS-02
type Misbehaviour struct {
	ClientId string  `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty" yaml:"client_id"`
	Header1  *Header `protobuf:"bytes,2,opt,name=header_1,json=header1,proto3" json:"header_1,omitempty" yaml:"header_1"`
	Header2  *Header `protobuf:"bytes,3,opt,name=header_2,json=header2,proto3" json:"header_2,omitempty" yaml:"header_2"`
}

func (m *Misbehaviour) Reset()         { *m = Misbehaviour{} }
func (m *Misbehaviour) String() string { return proto.CompactTextString(m) }
func (*Misbehaviour) ProtoMessage()    {}
func (*Misbehaviour) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{6}
}
func (m *Misbehaviour) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Misbehaviour) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Misbehaviour.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Misbehaviour) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Misbehaviour.Merge(m, src)
}
func (m *Misbehaviour) XXX_Size() int {
	return m.Size()
}
func (m *Misbehaviour) XXX_DiscardUnknown() {
	xxx_messageInfo_Misbehaviour.DiscardUnknown(m)
}

var xxx_messageInfo_Misbehaviour proto.InternalMessageInfo

// Header contains the neccessary data to proove finality about IBC commitments
type Header struct {
	*ParachainHeader `protobuf:"bytes,1,opt,name=parachain_header,json=parachainHeader,proto3,embedded=parachain_header" json:"parachain_header,omitempty" yaml:"signed_header"`
	// merkle proof of inclusion in header.extrinsic_root
	ExtrinsicProof [][]byte `protobuf:"bytes,2,rep,name=extrinsic_proof,json=extrinsicProof,proto3" json:"extrinsic_proof,omitempty"`
	// actual scale encoded timestamp extrinsic.
	TimestampExtrinsic Extrinsic `protobuf:"bytes,3,opt,name=timestamp_extrinsic,json=timestampExtrinsic,proto3" json:"timestamp_extrinsic"`
	// Data needed to prove parachain header finality
	ParachainHeaderProof ParachainHeaderProof `protobuf:"bytes,4,opt,name=parachain_header_proof,json=parachainHeaderProof,proto3" json:"parachain_header_proof"`
	// optional payload to update the mmr root hash.
	ClientUpdateProof *ClientUpdateProof `protobuf:"bytes,5,opt,name=client_update_proof,json=clientUpdateProof,proto3" json:"client_update_proof,omitempty"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{7}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

func (m *Header) GetExtrinsicProof() [][]byte {
	if m != nil {
		return m.ExtrinsicProof
	}
	return nil
}

func (m *Header) GetTimestampExtrinsic() Extrinsic {
	if m != nil {
		return m.TimestampExtrinsic
	}
	return Extrinsic{}
}

func (m *Header) GetParachainHeaderProof() ParachainHeaderProof {
	if m != nil {
		return m.ParachainHeaderProof
	}
	return ParachainHeaderProof{}
}

func (m *Header) GetClientUpdateProof() *ClientUpdateProof {
	if m != nil {
		return m.ClientUpdateProof
	}
	return nil
}

// borrowed from https://github.com/centrifuge/go-substrate-rpc-client/blob/7a18f81cc0e531eea6ee0bd96ab49f68aeee0c81/types/extrinsic.go#L46-L53
type Extrinsic struct {
	// Version is the encoded version flag (which encodes the raw transaction version and signing information in one byte)
	Version uint32 `protobuf:"varint,1,opt,name=Version,proto3" json:"Version,omitempty"`
	// Signature is the ExtrinsicSignatureV4, it's presence depends on the Version flag
	Signature *ExtrinsicSignatureV4 `protobuf:"bytes,2,opt,name=Signature,proto3" json:"Signature,omitempty"`
	// Method is the call this extrinsic wraps
	Method *Call `protobuf:"bytes,3,opt,name=Method,proto3" json:"Method,omitempty"`
}

func (m *Extrinsic) Reset()         { *m = Extrinsic{} }
func (m *Extrinsic) String() string { return proto.CompactTextString(m) }
func (*Extrinsic) ProtoMessage()    {}
func (*Extrinsic) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{8}
}
func (m *Extrinsic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Extrinsic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Extrinsic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Extrinsic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Extrinsic.Merge(m, src)
}
func (m *Extrinsic) XXX_Size() int {
	return m.Size()
}
func (m *Extrinsic) XXX_DiscardUnknown() {
	xxx_messageInfo_Extrinsic.DiscardUnknown(m)
}

var xxx_messageInfo_Extrinsic proto.InternalMessageInfo

func (m *Extrinsic) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Extrinsic) GetSignature() *ExtrinsicSignatureV4 {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Extrinsic) GetMethod() *Call {
	if m != nil {
		return m.Method
	}
	return nil
}

type ExtrinsicSignatureV4 struct {
	Signer    *MultiAddress   `protobuf:"bytes,1,opt,name=Signer,proto3" json:"Signer,omitempty"`
	Signature *MultiSignature `protobuf:"bytes,2,opt,name=Signature,proto3" json:"Signature,omitempty"`
	Era       *ExtrinsicEra   `protobuf:"bytes,3,opt,name=Era,proto3" json:"Era,omitempty"`
	Nonce     uint64          `protobuf:"varint,4,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	Tip       uint64          `protobuf:"varint,5,opt,name=Tip,proto3" json:"Tip,omitempty"`
}

func (m *ExtrinsicSignatureV4) Reset()         { *m = ExtrinsicSignatureV4{} }
func (m *ExtrinsicSignatureV4) String() string { return proto.CompactTextString(m) }
func (*ExtrinsicSignatureV4) ProtoMessage()    {}
func (*ExtrinsicSignatureV4) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{9}
}
func (m *ExtrinsicSignatureV4) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtrinsicSignatureV4) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtrinsicSignatureV4.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtrinsicSignatureV4) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtrinsicSignatureV4.Merge(m, src)
}
func (m *ExtrinsicSignatureV4) XXX_Size() int {
	return m.Size()
}
func (m *ExtrinsicSignatureV4) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtrinsicSignatureV4.DiscardUnknown(m)
}

var xxx_messageInfo_ExtrinsicSignatureV4 proto.InternalMessageInfo

func (m *ExtrinsicSignatureV4) GetSigner() *MultiAddress {
	if m != nil {
		return m.Signer
	}
	return nil
}

func (m *ExtrinsicSignatureV4) GetSignature() *MultiSignature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *ExtrinsicSignatureV4) GetEra() *ExtrinsicEra {
	if m != nil {
		return m.Era
	}
	return nil
}

func (m *ExtrinsicSignatureV4) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *ExtrinsicSignatureV4) GetTip() uint64 {
	if m != nil {
		return m.Tip
	}
	return 0
}

type MultiAddress struct {
	IsID        bool   `protobuf:"varint,1,opt,name=IsID,proto3" json:"IsID,omitempty"`
	AsID        []byte `protobuf:"bytes,2,opt,name=AsID,proto3" json:"AsID,omitempty"`
	IsIndex     bool   `protobuf:"varint,3,opt,name=IsIndex,proto3" json:"IsIndex,omitempty"`
	AsIndex     uint32 `protobuf:"varint,4,opt,name=AsIndex,proto3" json:"AsIndex,omitempty"`
	IsRaw       bool   `protobuf:"varint,5,opt,name=IsRaw,proto3" json:"IsRaw,omitempty"`
	AsRaw       []byte `protobuf:"bytes,6,opt,name=AsRaw,proto3" json:"AsRaw,omitempty"`
	IsAddress32 bool   `protobuf:"varint,7,opt,name=IsAddress32,proto3" json:"IsAddress32,omitempty"`
	AsAddress32 []byte `protobuf:"bytes,8,opt,name=AsAddress32,proto3" json:"AsAddress32,omitempty"`
	IsAddress20 bool   `protobuf:"varint,9,opt,name=IsAddress20,proto3" json:"IsAddress20,omitempty"`
	AsAddress20 []byte `protobuf:"bytes,10,opt,name=AsAddress20,proto3" json:"AsAddress20,omitempty"`
}

func (m *MultiAddress) Reset()         { *m = MultiAddress{} }
func (m *MultiAddress) String() string { return proto.CompactTextString(m) }
func (*MultiAddress) ProtoMessage()    {}
func (*MultiAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{10}
}
func (m *MultiAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiAddress.Merge(m, src)
}
func (m *MultiAddress) XXX_Size() int {
	return m.Size()
}
func (m *MultiAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiAddress.DiscardUnknown(m)
}

var xxx_messageInfo_MultiAddress proto.InternalMessageInfo

func (m *MultiAddress) GetIsID() bool {
	if m != nil {
		return m.IsID
	}
	return false
}

func (m *MultiAddress) GetAsID() []byte {
	if m != nil {
		return m.AsID
	}
	return nil
}

func (m *MultiAddress) GetIsIndex() bool {
	if m != nil {
		return m.IsIndex
	}
	return false
}

func (m *MultiAddress) GetAsIndex() uint32 {
	if m != nil {
		return m.AsIndex
	}
	return 0
}

func (m *MultiAddress) GetIsRaw() bool {
	if m != nil {
		return m.IsRaw
	}
	return false
}

func (m *MultiAddress) GetAsRaw() []byte {
	if m != nil {
		return m.AsRaw
	}
	return nil
}

func (m *MultiAddress) GetIsAddress32() bool {
	if m != nil {
		return m.IsAddress32
	}
	return false
}

func (m *MultiAddress) GetAsAddress32() []byte {
	if m != nil {
		return m.AsAddress32
	}
	return nil
}

func (m *MultiAddress) GetIsAddress20() bool {
	if m != nil {
		return m.IsAddress20
	}
	return false
}

func (m *MultiAddress) GetAsAddress20() []byte {
	if m != nil {
		return m.AsAddress20
	}
	return nil
}

type MultiSignature struct {
	IsEd25519 bool   `protobuf:"varint,1,opt,name=IsEd25519,proto3" json:"IsEd25519,omitempty"`
	AsEd25519 []byte `protobuf:"bytes,2,opt,name=AsEd25519,proto3" json:"AsEd25519,omitempty"`
	IsSr25519 bool   `protobuf:"varint,3,opt,name=IsSr25519,proto3" json:"IsSr25519,omitempty"`
	AsSr25519 []byte `protobuf:"bytes,4,opt,name=AsSr25519,proto3" json:"AsSr25519,omitempty"`
	IsEcdsa   bool   `protobuf:"varint,5,opt,name=IsEcdsa,proto3" json:"IsEcdsa,omitempty"`
	AsEcdsa   []byte `protobuf:"bytes,6,opt,name=AsEcdsa,proto3" json:"AsEcdsa,omitempty"`
}

func (m *MultiSignature) Reset()         { *m = MultiSignature{} }
func (m *MultiSignature) String() string { return proto.CompactTextString(m) }
func (*MultiSignature) ProtoMessage()    {}
func (*MultiSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{11}
}
func (m *MultiSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiSignature.Merge(m, src)
}
func (m *MultiSignature) XXX_Size() int {
	return m.Size()
}
func (m *MultiSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiSignature.DiscardUnknown(m)
}

var xxx_messageInfo_MultiSignature proto.InternalMessageInfo

func (m *MultiSignature) GetIsEd25519() bool {
	if m != nil {
		return m.IsEd25519
	}
	return false
}

func (m *MultiSignature) GetAsEd25519() []byte {
	if m != nil {
		return m.AsEd25519
	}
	return nil
}

func (m *MultiSignature) GetIsSr25519() bool {
	if m != nil {
		return m.IsSr25519
	}
	return false
}

func (m *MultiSignature) GetAsSr25519() []byte {
	if m != nil {
		return m.AsSr25519
	}
	return nil
}

func (m *MultiSignature) GetIsEcdsa() bool {
	if m != nil {
		return m.IsEcdsa
	}
	return false
}

func (m *MultiSignature) GetAsEcdsa() []byte {
	if m != nil {
		return m.AsEcdsa
	}
	return nil
}

// ExtrinsicEra indicates either a mortal or immortal extrinsic
type ExtrinsicEra struct {
	IsImmortalEra bool `protobuf:"varint,1,opt,name=IsImmortalEra,proto3" json:"IsImmortalEra,omitempty"`
	// AsImmortalEra ImmortalEra
	IsMortalEra bool       `protobuf:"varint,2,opt,name=IsMortalEra,proto3" json:"IsMortalEra,omitempty"`
	AsMortalEra *MortalEra `protobuf:"bytes,3,opt,name=AsMortalEra,proto3" json:"AsMortalEra,omitempty"`
}

func (m *ExtrinsicEra) Reset()         { *m = ExtrinsicEra{} }
func (m *ExtrinsicEra) String() string { return proto.CompactTextString(m) }
func (*ExtrinsicEra) ProtoMessage()    {}
func (*ExtrinsicEra) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{12}
}
func (m *ExtrinsicEra) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtrinsicEra) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtrinsicEra.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtrinsicEra) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtrinsicEra.Merge(m, src)
}
func (m *ExtrinsicEra) XXX_Size() int {
	return m.Size()
}
func (m *ExtrinsicEra) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtrinsicEra.DiscardUnknown(m)
}

var xxx_messageInfo_ExtrinsicEra proto.InternalMessageInfo

func (m *ExtrinsicEra) GetIsImmortalEra() bool {
	if m != nil {
		return m.IsImmortalEra
	}
	return false
}

func (m *ExtrinsicEra) GetIsMortalEra() bool {
	if m != nil {
		return m.IsMortalEra
	}
	return false
}

func (m *ExtrinsicEra) GetAsMortalEra() *MortalEra {
	if m != nil {
		return m.AsMortalEra
	}
	return nil
}

// MortalEra for an extrinsic, indicating period and phase
type MortalEra struct {
	First  uint32 `protobuf:"varint,1,opt,name=First,proto3" json:"First,omitempty"`
	Second uint32 `protobuf:"varint,2,opt,name=Second,proto3" json:"Second,omitempty"`
}

func (m *MortalEra) Reset()         { *m = MortalEra{} }
func (m *MortalEra) String() string { return proto.CompactTextString(m) }
func (*MortalEra) ProtoMessage()    {}
func (*MortalEra) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{13}
}
func (m *MortalEra) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MortalEra) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MortalEra.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MortalEra) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MortalEra.Merge(m, src)
}
func (m *MortalEra) XXX_Size() int {
	return m.Size()
}
func (m *MortalEra) XXX_DiscardUnknown() {
	xxx_messageInfo_MortalEra.DiscardUnknown(m)
}

var xxx_messageInfo_MortalEra proto.InternalMessageInfo

func (m *MortalEra) GetFirst() uint32 {
	if m != nil {
		return m.First
	}
	return 0
}

func (m *MortalEra) GetSecond() uint32 {
	if m != nil {
		return m.Second
	}
	return 0
}

// Call is the extrinsic function descriptor
type Call struct {
	CallIndex *CallIndex `protobuf:"bytes,1,opt,name=CallIndex,proto3" json:"CallIndex,omitempty"`
	Args      []byte     `protobuf:"bytes,2,opt,name=Args,proto3" json:"Args,omitempty"`
}

func (m *Call) Reset()         { *m = Call{} }
func (m *Call) String() string { return proto.CompactTextString(m) }
func (*Call) ProtoMessage()    {}
func (*Call) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{14}
}
func (m *Call) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Call) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Call.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Call) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Call.Merge(m, src)
}
func (m *Call) XXX_Size() int {
	return m.Size()
}
func (m *Call) XXX_DiscardUnknown() {
	xxx_messageInfo_Call.DiscardUnknown(m)
}

var xxx_messageInfo_Call proto.InternalMessageInfo

func (m *Call) GetCallIndex() *CallIndex {
	if m != nil {
		return m.CallIndex
	}
	return nil
}

func (m *Call) GetArgs() []byte {
	if m != nil {
		return m.Args
	}
	return nil
}

// Call is the extrinsic function descriptor
type CallIndex struct {
	SectionIndex uint32 `protobuf:"varint,1,opt,name=SectionIndex,proto3" json:"SectionIndex,omitempty"`
	MethodIndex  uint32 `protobuf:"varint,2,opt,name=MethodIndex,proto3" json:"MethodIndex,omitempty"`
}

func (m *CallIndex) Reset()         { *m = CallIndex{} }
func (m *CallIndex) String() string { return proto.CompactTextString(m) }
func (*CallIndex) ProtoMessage()    {}
func (*CallIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{15}
}
func (m *CallIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CallIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CallIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CallIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CallIndex.Merge(m, src)
}
func (m *CallIndex) XXX_Size() int {
	return m.Size()
}
func (m *CallIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_CallIndex.DiscardUnknown(m)
}

var xxx_messageInfo_CallIndex proto.InternalMessageInfo

func (m *CallIndex) GetSectionIndex() uint32 {
	if m != nil {
		return m.SectionIndex
	}
	return 0
}

func (m *CallIndex) GetMethodIndex() uint32 {
	if m != nil {
		return m.MethodIndex
	}
	return 0
}

// borrowed from: https://github.com/centrifuge/go-substrate-rpc-client/blob/7a18f81cc0e531eea6ee0bd96ab49f68aeee0c81/types/header.go?_pjax=%23js-repo-pjax-container%2C%20div%5Bitemtype%3D%22http%3A%2F%2Fschema.org%2FSoftwareSourceCode%22%5D%20main%2C%20%5Bdata-pjax-container%5D#L28-L34
type ParachainHeader struct {
	ParentHash     []byte        `protobuf:"bytes,1,opt,name=ParentHash,proto3" json:"ParentHash,omitempty"`
	Number         uint32        `protobuf:"varint,2,opt,name=Number,proto3" json:"Number,omitempty"`
	StateRoot      []byte        `protobuf:"bytes,3,opt,name=StateRoot,proto3" json:"StateRoot,omitempty"`
	ExtrinsicsRoot []byte        `protobuf:"bytes,4,opt,name=ExtrinsicsRoot,proto3" json:"ExtrinsicsRoot,omitempty"`
	Digest         []*DigestItem `protobuf:"bytes,5,rep,name=Digest,proto3" json:"Digest,omitempty"`
}

func (m *ParachainHeader) Reset()         { *m = ParachainHeader{} }
func (m *ParachainHeader) String() string { return proto.CompactTextString(m) }
func (*ParachainHeader) ProtoMessage()    {}
func (*ParachainHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{16}
}
func (m *ParachainHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParachainHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParachainHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParachainHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParachainHeader.Merge(m, src)
}
func (m *ParachainHeader) XXX_Size() int {
	return m.Size()
}
func (m *ParachainHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ParachainHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ParachainHeader proto.InternalMessageInfo

func (m *ParachainHeader) GetParentHash() []byte {
	if m != nil {
		return m.ParentHash
	}
	return nil
}

func (m *ParachainHeader) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *ParachainHeader) GetStateRoot() []byte {
	if m != nil {
		return m.StateRoot
	}
	return nil
}

func (m *ParachainHeader) GetExtrinsicsRoot() []byte {
	if m != nil {
		return m.ExtrinsicsRoot
	}
	return nil
}

func (m *ParachainHeader) GetDigest() []*DigestItem {
	if m != nil {
		return m.Digest
	}
	return nil
}

type DigestItem struct {
	IsChangesTrieRoot   bool               `protobuf:"varint,1,opt,name=IsChangesTrieRoot,proto3" json:"IsChangesTrieRoot,omitempty"`
	AsChangesTrieRoot   []byte             `protobuf:"bytes,2,opt,name=AsChangesTrieRoot,proto3" json:"AsChangesTrieRoot,omitempty"`
	IsPreRuntime        bool               `protobuf:"varint,3,opt,name=IsPreRuntime,proto3" json:"IsPreRuntime,omitempty"`
	AsPreRuntime        *PreRuntime        `protobuf:"bytes,4,opt,name=AsPreRuntime,proto3" json:"AsPreRuntime,omitempty"`
	IsConsensus         bool               `protobuf:"varint,5,opt,name=IsConsensus,proto3" json:"IsConsensus,omitempty"`
	AsConsensus         *Consensus         `protobuf:"bytes,6,opt,name=AsConsensus,proto3" json:"AsConsensus,omitempty"`
	IsSeal              bool               `protobuf:"varint,7,opt,name=IsSeal,proto3" json:"IsSeal,omitempty"`
	AsSeal              *Seal              `protobuf:"bytes,8,opt,name=AsSeal,proto3" json:"AsSeal,omitempty"`
	IsChangesTrieSignal bool               `protobuf:"varint,9,opt,name=IsChangesTrieSignal,proto3" json:"IsChangesTrieSignal,omitempty"`
	AsChangesTrieSignal *ChangesTrieSignal `protobuf:"bytes,10,opt,name=AsChangesTrieSignal,proto3" json:"AsChangesTrieSignal,omitempty"`
	IsOther             bool               `protobuf:"varint,11,opt,name=IsOther,proto3" json:"IsOther,omitempty"`
	AsOther             []byte             `protobuf:"bytes,12,opt,name=AsOther,proto3" json:"AsOther,omitempty"`
}

func (m *DigestItem) Reset()         { *m = DigestItem{} }
func (m *DigestItem) String() string { return proto.CompactTextString(m) }
func (*DigestItem) ProtoMessage()    {}
func (*DigestItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{17}
}
func (m *DigestItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DigestItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestItem.Merge(m, src)
}
func (m *DigestItem) XXX_Size() int {
	return m.Size()
}
func (m *DigestItem) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestItem.DiscardUnknown(m)
}

var xxx_messageInfo_DigestItem proto.InternalMessageInfo

func (m *DigestItem) GetIsChangesTrieRoot() bool {
	if m != nil {
		return m.IsChangesTrieRoot
	}
	return false
}

func (m *DigestItem) GetAsChangesTrieRoot() []byte {
	if m != nil {
		return m.AsChangesTrieRoot
	}
	return nil
}

func (m *DigestItem) GetIsPreRuntime() bool {
	if m != nil {
		return m.IsPreRuntime
	}
	return false
}

func (m *DigestItem) GetAsPreRuntime() *PreRuntime {
	if m != nil {
		return m.AsPreRuntime
	}
	return nil
}

func (m *DigestItem) GetIsConsensus() bool {
	if m != nil {
		return m.IsConsensus
	}
	return false
}

func (m *DigestItem) GetAsConsensus() *Consensus {
	if m != nil {
		return m.AsConsensus
	}
	return nil
}

func (m *DigestItem) GetIsSeal() bool {
	if m != nil {
		return m.IsSeal
	}
	return false
}

func (m *DigestItem) GetAsSeal() *Seal {
	if m != nil {
		return m.AsSeal
	}
	return nil
}

func (m *DigestItem) GetIsChangesTrieSignal() bool {
	if m != nil {
		return m.IsChangesTrieSignal
	}
	return false
}

func (m *DigestItem) GetAsChangesTrieSignal() *ChangesTrieSignal {
	if m != nil {
		return m.AsChangesTrieSignal
	}
	return nil
}

func (m *DigestItem) GetIsOther() bool {
	if m != nil {
		return m.IsOther
	}
	return false
}

func (m *DigestItem) GetAsOther() []byte {
	if m != nil {
		return m.AsOther
	}
	return nil
}

type PreRuntime struct {
	ConsensusEngineID uint32 `protobuf:"varint,1,opt,name=ConsensusEngineID,proto3" json:"ConsensusEngineID,omitempty"`
	Bytes             []byte `protobuf:"bytes,2,opt,name=Bytes,proto3" json:"Bytes,omitempty"`
}

func (m *PreRuntime) Reset()         { *m = PreRuntime{} }
func (m *PreRuntime) String() string { return proto.CompactTextString(m) }
func (*PreRuntime) ProtoMessage()    {}
func (*PreRuntime) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{18}
}
func (m *PreRuntime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreRuntime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreRuntime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreRuntime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreRuntime.Merge(m, src)
}
func (m *PreRuntime) XXX_Size() int {
	return m.Size()
}
func (m *PreRuntime) XXX_DiscardUnknown() {
	xxx_messageInfo_PreRuntime.DiscardUnknown(m)
}

var xxx_messageInfo_PreRuntime proto.InternalMessageInfo

func (m *PreRuntime) GetConsensusEngineID() uint32 {
	if m != nil {
		return m.ConsensusEngineID
	}
	return 0
}

func (m *PreRuntime) GetBytes() []byte {
	if m != nil {
		return m.Bytes
	}
	return nil
}

type Consensus struct {
	ConsensusEngineID uint32 `protobuf:"varint,1,opt,name=ConsensusEngineID,proto3" json:"ConsensusEngineID,omitempty"`
	Bytes             []byte `protobuf:"bytes,2,opt,name=Bytes,proto3" json:"Bytes,omitempty"`
}

func (m *Consensus) Reset()         { *m = Consensus{} }
func (m *Consensus) String() string { return proto.CompactTextString(m) }
func (*Consensus) ProtoMessage()    {}
func (*Consensus) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{19}
}
func (m *Consensus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Consensus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Consensus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Consensus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Consensus.Merge(m, src)
}
func (m *Consensus) XXX_Size() int {
	return m.Size()
}
func (m *Consensus) XXX_DiscardUnknown() {
	xxx_messageInfo_Consensus.DiscardUnknown(m)
}

var xxx_messageInfo_Consensus proto.InternalMessageInfo

func (m *Consensus) GetConsensusEngineID() uint32 {
	if m != nil {
		return m.ConsensusEngineID
	}
	return 0
}

func (m *Consensus) GetBytes() []byte {
	if m != nil {
		return m.Bytes
	}
	return nil
}

type Seal struct {
	ConsensusEngineID uint32 `protobuf:"varint,1,opt,name=ConsensusEngineID,proto3" json:"ConsensusEngineID,omitempty"`
	Bytes             []byte `protobuf:"bytes,2,opt,name=Bytes,proto3" json:"Bytes,omitempty"`
}

func (m *Seal) Reset()         { *m = Seal{} }
func (m *Seal) String() string { return proto.CompactTextString(m) }
func (*Seal) ProtoMessage()    {}
func (*Seal) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{20}
}
func (m *Seal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Seal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Seal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Seal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Seal.Merge(m, src)
}
func (m *Seal) XXX_Size() int {
	return m.Size()
}
func (m *Seal) XXX_DiscardUnknown() {
	xxx_messageInfo_Seal.DiscardUnknown(m)
}

var xxx_messageInfo_Seal proto.InternalMessageInfo

func (m *Seal) GetConsensusEngineID() uint32 {
	if m != nil {
		return m.ConsensusEngineID
	}
	return 0
}

func (m *Seal) GetBytes() []byte {
	if m != nil {
		return m.Bytes
	}
	return nil
}

type ChangesTrieSignal struct {
	IsNewConfiguration bool   `protobuf:"varint,1,opt,name=IsNewConfiguration,proto3" json:"IsNewConfiguration,omitempty"`
	AsNewConfiguration []byte `protobuf:"bytes,2,opt,name=AsNewConfiguration,proto3" json:"AsNewConfiguration,omitempty"`
}

func (m *ChangesTrieSignal) Reset()         { *m = ChangesTrieSignal{} }
func (m *ChangesTrieSignal) String() string { return proto.CompactTextString(m) }
func (*ChangesTrieSignal) ProtoMessage()    {}
func (*ChangesTrieSignal) Descriptor() ([]byte, []int) {
	return fileDescriptor_43205c4bfbe9a422, []int{21}
}
func (m *ChangesTrieSignal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangesTrieSignal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangesTrieSignal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangesTrieSignal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangesTrieSignal.Merge(m, src)
}
func (m *ChangesTrieSignal) XXX_Size() int {
	return m.Size()
}
func (m *ChangesTrieSignal) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangesTrieSignal.DiscardUnknown(m)
}

var xxx_messageInfo_ChangesTrieSignal proto.InternalMessageInfo

func (m *ChangesTrieSignal) GetIsNewConfiguration() bool {
	if m != nil {
		return m.IsNewConfiguration
	}
	return false
}

func (m *ChangesTrieSignal) GetAsNewConfiguration() []byte {
	if m != nil {
		return m.AsNewConfiguration
	}
	return nil
}

func init() {
	proto.RegisterType((*MmrLeafPartial)(nil), "ibc.lightclients.beefy.v1.MmrLeafPartial")
	proto.RegisterType((*BeefyAuthoritySet)(nil), "ibc.lightclients.beefy.v1.BeefyAuthoritySet")
	proto.RegisterType((*ClientState)(nil), "ibc.lightclients.beefy.v1.ClientState")
	proto.RegisterType((*ParachainHeaderProof)(nil), "ibc.lightclients.beefy.v1.ParachainHeaderProof")
	proto.RegisterType((*ClientUpdateProof)(nil), "ibc.lightclients.beefy.v1.ClientUpdateProof")
	proto.RegisterType((*ConsensusState)(nil), "ibc.lightclients.beefy.v1.ConsensusState")
	proto.RegisterType((*Misbehaviour)(nil), "ibc.lightclients.beefy.v1.Misbehaviour")
	proto.RegisterType((*Header)(nil), "ibc.lightclients.beefy.v1.Header")
	proto.RegisterType((*Extrinsic)(nil), "ibc.lightclients.beefy.v1.Extrinsic")
	proto.RegisterType((*ExtrinsicSignatureV4)(nil), "ibc.lightclients.beefy.v1.ExtrinsicSignatureV4")
	proto.RegisterType((*MultiAddress)(nil), "ibc.lightclients.beefy.v1.MultiAddress")
	proto.RegisterType((*MultiSignature)(nil), "ibc.lightclients.beefy.v1.MultiSignature")
	proto.RegisterType((*ExtrinsicEra)(nil), "ibc.lightclients.beefy.v1.ExtrinsicEra")
	proto.RegisterType((*MortalEra)(nil), "ibc.lightclients.beefy.v1.MortalEra")
	proto.RegisterType((*Call)(nil), "ibc.lightclients.beefy.v1.Call")
	proto.RegisterType((*CallIndex)(nil), "ibc.lightclients.beefy.v1.CallIndex")
	proto.RegisterType((*ParachainHeader)(nil), "ibc.lightclients.beefy.v1.ParachainHeader")
	proto.RegisterType((*DigestItem)(nil), "ibc.lightclients.beefy.v1.DigestItem")
	proto.RegisterType((*PreRuntime)(nil), "ibc.lightclients.beefy.v1.PreRuntime")
	proto.RegisterType((*Consensus)(nil), "ibc.lightclients.beefy.v1.Consensus")
	proto.RegisterType((*Seal)(nil), "ibc.lightclients.beefy.v1.Seal")
	proto.RegisterType((*ChangesTrieSignal)(nil), "ibc.lightclients.beefy.v1.ChangesTrieSignal")
}

func init() {
	proto.RegisterFile("ibc/lightclients/beefy/v1/beefy.proto", fileDescriptor_43205c4bfbe9a422)
}

var fileDescriptor_43205c4bfbe9a422 = []byte{
	// 1641 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xdd, 0x8e, 0x13, 0xcb,
	0x11, 0xde, 0x59, 0x7b, 0xbd, 0x76, 0xd9, 0xde, 0x9f, 0x5e, 0x0b, 0x19, 0x44, 0xec, 0xcd, 0x04,
	0xc2, 0x12, 0x81, 0xbd, 0x36, 0x41, 0x11, 0x48, 0x51, 0x62, 0x2f, 0x4b, 0x18, 0x94, 0x5d, 0x36,
	0x6d, 0xc2, 0x05, 0x89, 0x70, 0xc6, 0x9e, 0x5e, 0x7b, 0xc4, 0xfc, 0x58, 0xd3, 0xed, 0x85, 0xbd,
	0x8e, 0x14, 0xe5, 0x92, 0x27, 0x40, 0x79, 0x81, 0xbc, 0x41, 0x1e, 0x80, 0x48, 0x47, 0x47, 0xe8,
	0xe8, 0x5c, 0x70, 0xb5, 0xe7, 0x68, 0x79, 0x03, 0x9e, 0xe0, 0xa8, 0x7f, 0xe6, 0xc7, 0x3f, 0xc7,
	0x0b, 0x12, 0x57, 0xee, 0xaa, 0xfa, 0xaa, 0xba, 0xaa, 0xba, 0xaa, 0xba, 0x3d, 0x70, 0xdd, 0xee,
	0xf5, 0xeb, 0x8e, 0x3d, 0x18, 0xb2, 0xbe, 0x63, 0x13, 0x8f, 0xd1, 0x7a, 0x8f, 0x90, 0xe3, 0xd3,
	0xfa, 0x49, 0x43, 0x2e, 0x6a, 0xa3, 0xc0, 0x67, 0x3e, 0xba, 0x6c, 0xf7, 0xfa, 0xb5, 0x24, 0xac,
	0x26, 0xa5, 0x27, 0x8d, 0x2b, 0x95, 0x81, 0xef, 0x0f, 0x1c, 0x52, 0x17, 0xc0, 0xde, 0xf8, 0xb8,
	0x6e, 0x8d, 0x03, 0x93, 0xd9, 0xbe, 0x27, 0x55, 0xaf, 0x54, 0xa7, 0xe5, 0xcc, 0x76, 0x09, 0x65,
	0xa6, 0x3b, 0x52, 0x80, 0xd2, 0xc0, 0x1f, 0xf8, 0x62, 0x59, 0xe7, 0x2b, 0xc9, 0xd5, 0xbf, 0xd3,
	0x60, 0xed, 0xc0, 0x0d, 0xfe, 0x4c, 0xcc, 0xe3, 0x23, 0x33, 0x60, 0xb6, 0xe9, 0xa0, 0x32, 0xac,
	0x9e, 0x90, 0x80, 0xda, 0xbe, 0x57, 0xd6, 0xb6, 0xb5, 0x9d, 0x34, 0x0e, 0x49, 0xf4, 0x2b, 0x28,
	0x8e, 0xcc, 0x80, 0x78, 0xac, 0xeb, 0x8d, 0xdd, 0x1e, 0x09, 0xca, 0xcb, 0x42, 0x5e, 0x90, 0xcc,
	0x43, 0xc1, 0x43, 0x55, 0xc8, 0x2b, 0xd0, 0xd0, 0xa4, 0xc3, 0x72, 0x6a, 0x5b, 0xdb, 0x29, 0x60,
	0x90, 0xac, 0x47, 0x26, 0x1d, 0xa2, 0x7f, 0x00, 0xf2, 0xc8, 0x6b, 0xd6, 0x35, 0xc7, 0x6c, 0xe8,
	0x07, 0x36, 0x3b, 0xed, 0x52, 0xc2, 0xca, 0xe9, 0x6d, 0x6d, 0x27, 0xdf, 0xbc, 0x55, 0xfb, 0xd9,
	0x0c, 0xd4, 0xda, 0x7c, 0xd1, 0x0a, 0x95, 0x3a, 0x84, 0xb5, 0xd3, 0xef, 0xce, 0xaa, 0x4b, 0x78,
	0x83, 0x5b, 0x4b, 0xf2, 0xf5, 0x01, 0x6c, 0xce, 0x80, 0xd1, 0x1a, 0x2c, 0xdb, 0x96, 0x8a, 0x68,
	0xd9, 0xb6, 0xd0, 0x06, 0xa4, 0x1c, 0xe2, 0xa9, 0x10, 0xf8, 0x12, 0xed, 0xc2, 0x56, 0xe4, 0xd3,
	0x01, 0x09, 0x5e, 0x3a, 0x04, 0xfb, 0x3e, 0x53, 0x11, 0xcc, 0x13, 0xe9, 0xdf, 0x68, 0x90, 0xdf,
	0x13, 0x7e, 0x76, 0x98, 0xc9, 0x08, 0xba, 0x0c, 0xd9, 0xfe, 0xd0, 0xb4, 0xbd, 0xae, 0xda, 0x29,
	0x87, 0x57, 0x05, 0x6d, 0x58, 0x48, 0x87, 0xa2, 0xeb, 0x06, 0xdd, 0xc0, 0xf7, 0x27, 0x12, 0x93,
	0x77, 0xdd, 0x80, 0x9b, 0x12, 0x99, 0xb9, 0x05, 0x9b, 0x8e, 0xc9, 0x08, 0x65, 0xc2, 0xfb, 0x47,
	0x84, 0xa7, 0x41, 0x24, 0x26, 0x8d, 0x67, 0x05, 0xe8, 0x31, 0xe4, 0x22, 0x9f, 0xca, 0x2b, 0x5f,
	0x9e, 0x3e, 0x1c, 0xab, 0xdf, 0x4f, 0xff, 0xfb, 0x3f, 0xd5, 0x25, 0xfd, 0xff, 0x1a, 0x94, 0x8e,
	0xcc, 0xc0, 0x14, 0x3e, 0x3f, 0x22, 0xa6, 0x45, 0x82, 0xa3, 0xc0, 0xf7, 0x8f, 0xd1, 0x2f, 0x00,
	0x1c, 0x62, 0x1e, 0x77, 0x6d, 0xcf, 0x22, 0xaf, 0x55, 0x0e, 0x73, 0x9c, 0x63, 0x70, 0x06, 0xba,
	0x04, 0x99, 0x11, 0xc7, 0xd1, 0xf2, 0xf2, 0x76, 0x6a, 0xa7, 0x80, 0x15, 0xc5, 0x4b, 0x61, 0x48,
	0x4c, 0x8b, 0x76, 0x05, 0x5d, 0x4e, 0x0b, 0x21, 0x08, 0x96, 0xb4, 0xdb, 0x81, 0x0d, 0x9e, 0x14,
	0x61, 0x7b, 0x24, 0xcb, 0x4f, 0x45, 0x72, 0x73, 0x41, 0x24, 0x93, 0xf5, 0x8a, 0xd7, 0xdc, 0x09,
	0x5a, 0xc5, 0xf2, 0x2f, 0x0d, 0x36, 0xe5, 0xd1, 0xfc, 0x75, 0x64, 0x99, 0x8c, 0xc8, 0x0d, 0x67,
	0x4e, 0x41, 0x9b, 0x3d, 0x85, 0x0a, 0x00, 0xb5, 0x07, 0x9e, 0xc9, 0xc6, 0x01, 0x09, 0x23, 0x4a,
	0x70, 0xd0, 0x0d, 0x58, 0x8f, 0x4b, 0x57, 0x46, 0x96, 0x12, 0xa0, 0xb5, 0x88, 0x2d, 0x36, 0x53,
	0x8e, 0x78, 0xb0, 0xb6, 0xe7, 0x7b, 0x94, 0x78, 0x74, 0x4c, 0x65, 0x95, 0xb4, 0x21, 0x17, 0x35,
	0xa7, 0x70, 0x20, 0xdf, 0xbc, 0x52, 0x93, 0xed, 0x5b, 0x0b, 0xdb, 0xb7, 0xf6, 0x34, 0x44, 0xb4,
	0xb3, 0xbc, 0xca, 0xdf, 0xfc, 0x50, 0xd5, 0x70, 0xac, 0x86, 0x10, 0xa4, 0x79, 0x10, 0xa2, 0x7c,
	0x0b, 0x58, 0xac, 0xd5, 0x7e, 0xff, 0x5c, 0x86, 0xc2, 0x81, 0x4d, 0x7b, 0x64, 0x68, 0x9e, 0xd8,
	0xfe, 0x38, 0x40, 0x0d, 0xc8, 0xc9, 0x14, 0x46, 0x55, 0xd9, 0x2e, 0x7d, 0x3a, 0xab, 0x6e, 0x9c,
	0x9a, 0xae, 0x73, 0x5f, 0x8f, 0x44, 0x3a, 0xce, 0xca, 0xb5, 0x61, 0xa1, 0xbf, 0x43, 0x76, 0x28,
	0x8e, 0xbf, 0xdb, 0x10, 0x3b, 0xe4, 0x9b, 0xbf, 0x5c, 0x70, 0x1e, 0xb2, 0x52, 0xda, 0x95, 0xf3,
	0xb3, 0xea, 0xaa, 0x5c, 0x37, 0x3e, 0x9d, 0x55, 0xd7, 0xa5, 0xfd, 0xd0, 0x8e, 0x8e, 0x57, 0xe5,
	0xb2, 0x91, 0xb0, 0xde, 0x14, 0x5d, 0xf0, 0xa5, 0xd6, 0x9b, 0x33, 0xd6, 0x9b, 0x91, 0xf5, 0xa6,
	0xca, 0xc2, 0xf7, 0x29, 0xc8, 0x48, 0x34, 0xa2, 0xb0, 0x31, 0x0a, 0x8b, 0xba, 0x2b, 0x51, 0x2a,
	0xeb, 0xbf, 0x59, 0xb0, 0xed, 0x54, 0x1f, 0xb4, 0xaf, 0xbe, 0x3f, 0xab, 0x6a, 0x9f, 0xce, 0xaa,
	0x25, 0xb9, 0x31, 0xaf, 0x07, 0x62, 0x29, 0x73, 0x3a, 0x5e, 0x1f, 0x4d, 0xc2, 0x79, 0x91, 0x90,
	0xd7, 0x2c, 0xb0, 0x3d, 0x6a, 0xf7, 0x55, 0x91, 0xc8, 0x4a, 0x5a, 0x8b, 0xd8, 0xb2, 0x22, 0xff,
	0x06, 0x5b, 0xd1, 0xa9, 0x76, 0x23, 0x99, 0xca, 0xcb, 0xb5, 0x05, 0x0e, 0xee, 0x87, 0x58, 0x35,
	0x06, 0x51, 0x64, 0x26, 0x92, 0xa0, 0x97, 0x70, 0x69, 0x3a, 0xf4, 0xa8, 0x17, 0xb9, 0xfd, 0xfa,
	0xe7, 0x27, 0x40, 0x78, 0xab, 0xb6, 0x2a, 0x8d, 0xe6, 0x0d, 0x89, 0x1e, 0x6c, 0xa9, 0x62, 0x1a,
	0x8b, 0x8e, 0x53, 0x3b, 0x5d, 0x3c, 0x99, 0x66, 0xda, 0x54, 0x6c, 0xa3, 0xe1, 0xcd, 0xfe, 0xb4,
	0x40, 0xff, 0xaf, 0x06, 0xb9, 0x38, 0xbc, 0x32, 0xac, 0x3e, 0x4b, 0xdc, 0x54, 0x45, 0x1c, 0x92,
	0xe8, 0x00, 0x72, 0x9d, 0xb0, 0x63, 0x55, 0x05, 0xd7, 0x3f, 0x27, 0x97, 0x91, 0xd2, 0xb3, 0xdf,
	0xe2, 0xd8, 0x02, 0xfa, 0x1d, 0x64, 0x0e, 0x08, 0x1b, 0xfa, 0x96, 0x3a, 0x97, 0xea, 0xa2, 0x68,
	0x4c, 0xc7, 0xc1, 0x0a, 0xce, 0x9b, 0xb1, 0x34, 0xcf, 0x38, 0xfa, 0x03, 0x64, 0x38, 0x19, 0x95,
	0xe2, 0x8d, 0x45, 0xf3, 0x6e, 0xec, 0x30, 0xbb, 0x65, 0x59, 0x01, 0xa1, 0x14, 0x2b, 0x35, 0xf4,
	0xa7, 0xd9, 0x08, 0x6f, 0x5e, 0x64, 0x23, 0x52, 0x48, 0xc6, 0x76, 0x0f, 0x52, 0xfb, 0x81, 0xa9,
	0x02, 0xbb, 0xf1, 0x39, 0x49, 0xda, 0x0f, 0x4c, 0xcc, 0x75, 0x50, 0x09, 0x56, 0x0e, 0x7d, 0xaf,
	0x4f, 0xd4, 0x1d, 0x25, 0x09, 0x7e, 0xb1, 0x3e, 0xb5, 0x47, 0xe2, 0xdc, 0xd3, 0x98, 0x2f, 0xf5,
	0xb7, 0x7c, 0x24, 0x25, 0x82, 0xe0, 0xd3, 0xcb, 0xa0, 0xc6, 0x03, 0x11, 0x7b, 0x16, 0x8b, 0x35,
	0xe7, 0xb5, 0x38, 0x4f, 0x4d, 0x34, 0xbe, 0xe6, 0x07, 0x6c, 0x50, 0x71, 0xc7, 0x08, 0xff, 0xb2,
	0x38, 0x24, 0xb9, 0xa4, 0xa5, 0x24, 0x69, 0x79, 0xf4, 0x8a, 0xe4, 0x4e, 0x19, 0x14, 0x9b, 0xaf,
	0x84, 0x03, 0x59, 0x2c, 0x09, 0xce, 0x6d, 0x09, 0x6e, 0x46, 0x98, 0x97, 0x04, 0xda, 0x86, 0xbc,
	0x41, 0x95, 0x53, 0x77, 0x9a, 0xe5, 0x55, 0xa1, 0x91, 0x64, 0x71, 0x44, 0x2b, 0x81, 0xc8, 0xca,
	0xeb, 0xa2, 0x35, 0x89, 0x88, 0x14, 0x9a, 0xbb, 0xe5, 0xdc, 0x94, 0x8d, 0xe6, 0xee, 0x84, 0x8d,
	0xe6, 0x6e, 0x19, 0xa6, 0x6c, 0x34, 0x77, 0xf5, 0xff, 0xf1, 0x57, 0xd8, 0xc4, 0x09, 0xa1, 0xab,
	0x90, 0x33, 0xe8, 0xbe, 0xd5, 0xbc, 0x7b, 0xb7, 0x71, 0x4f, 0xe5, 0x29, 0x66, 0x70, 0x69, 0x2b,
	0x92, 0xca, 0x8c, 0xc5, 0x0c, 0xa9, 0xdb, 0x09, 0xa4, 0x34, 0x15, 0xea, 0x2a, 0x86, 0xd4, 0x0d,
	0xa5, 0xe9, 0x50, 0x37, 0x94, 0x8a, 0x94, 0xef, 0xf7, 0x2d, 0x6a, 0xaa, 0x04, 0x86, 0xa4, 0x4c,
	0xb9, 0x94, 0xc8, 0x24, 0x86, 0xa4, 0xfe, 0x56, 0x83, 0x42, 0xb2, 0x3a, 0xd0, 0x35, 0x28, 0x1a,
	0xd4, 0x70, 0x5d, 0x3f, 0x60, 0xa6, 0xc3, 0xab, 0x4b, 0x06, 0x30, 0xc9, 0x94, 0x99, 0x3b, 0x88,
	0x30, 0xcb, 0x61, 0xe6, 0x22, 0x16, 0x7a, 0xc8, 0x33, 0x17, 0x23, 0x2e, 0x1e, 0x8a, 0x11, 0x16,
	0x27, 0x15, 0xf5, 0x7b, 0x90, 0x8b, 0x8d, 0x96, 0x60, 0xe5, 0xa1, 0x1d, 0x50, 0xa6, 0x66, 0x86,
	0x24, 0xf8, 0x1b, 0xa6, 0x43, 0xfa, 0xbe, 0x67, 0x09, 0x3f, 0x8a, 0x58, 0x51, 0xfa, 0x0b, 0x48,
	0xf3, 0x8e, 0xe6, 0x97, 0x36, 0xff, 0x35, 0xa2, 0x17, 0xd0, 0x62, 0x47, 0x22, 0x2c, 0x8e, 0xd5,
	0x44, 0x89, 0x07, 0x03, 0x1a, 0x95, 0x78, 0x30, 0xa0, 0xfa, 0x5f, 0x12, 0x76, 0x91, 0x0e, 0x85,
	0x0e, 0xe9, 0xf3, 0x57, 0x7d, 0xbc, 0x4f, 0x11, 0x4f, 0xf0, 0x78, 0xd6, 0xe4, 0x70, 0x91, 0x10,
	0xe9, 0x6d, 0x92, 0xa5, 0x7f, 0xab, 0xc1, 0xfa, 0xd4, 0xf4, 0xe6, 0x8f, 0x9a, 0xa3, 0xe8, 0x09,
	0xae, 0x5e, 0x3d, 0x09, 0x0e, 0x0f, 0xff, 0x30, 0x7e, 0xd3, 0x17, 0xb1, 0xa2, 0x78, 0xb1, 0x88,
	0x47, 0x4b, 0xe2, 0x25, 0x1c, 0x33, 0xd0, 0xaf, 0x61, 0x2d, 0x3a, 0x77, 0x2a, 0x20, 0xb2, 0x9e,
	0xa6, 0xb8, 0xe8, 0xf7, 0x90, 0x79, 0x60, 0x0f, 0x08, 0x65, 0xe5, 0x95, 0xed, 0xd4, 0x4e, 0xbe,
	0x79, 0x7d, 0x41, 0xe6, 0x24, 0xd0, 0x60, 0xc4, 0xc5, 0x4a, 0x49, 0xff, 0x90, 0x06, 0x88, 0xd9,
	0xfc, 0x99, 0x6c, 0xd0, 0xbd, 0xa1, 0xe9, 0x0d, 0x08, 0x7d, 0x1a, 0xd8, 0xd2, 0x37, 0x59, 0x61,
	0xb3, 0x02, 0x8e, 0x6e, 0xcd, 0xa0, 0xe5, 0x09, 0xcc, 0x0a, 0xf8, 0x09, 0x18, 0xf4, 0x28, 0x20,
	0x78, 0xec, 0xf1, 0xfb, 0x54, 0x75, 0xcf, 0x04, 0x0f, 0x19, 0x50, 0x68, 0x25, 0x31, 0xf2, 0x2e,
	0x5d, 0x14, 0x53, 0x0c, 0xc6, 0x13, 0xaa, 0xb2, 0x05, 0xa2, 0xe7, 0xa1, 0xea, 0xb8, 0x24, 0x4b,
	0xb6, 0x40, 0x8c, 0xc8, 0x5c, 0x5c, 0x79, 0x21, 0x16, 0x27, 0x15, 0xf9, 0x01, 0x1b, 0xb4, 0x43,
	0x4c, 0x47, 0x4d, 0x39, 0x45, 0xf1, 0xab, 0xad, 0x25, 0xf9, 0xd9, 0x0b, 0xaf, 0x36, 0x0e, 0xc3,
	0x0a, 0xce, 0xff, 0x2d, 0x4d, 0x24, 0x5b, 0x8c, 0x2e, 0x47, 0xcd, 0xbf, 0x79, 0x22, 0xf4, 0x02,
	0xb6, 0x5a, 0x73, 0x34, 0xe0, 0xe2, 0x07, 0xc2, 0xb4, 0x0e, 0x9e, 0x67, 0x48, 0x8e, 0xae, 0x27,
	0x6c, 0x48, 0x82, 0x72, 0x3e, 0x1c, 0x5d, 0x82, 0x94, 0xa3, 0x4b, 0x4a, 0x0a, 0xe1, 0xe8, 0x12,
	0xa4, 0x7e, 0x04, 0x90, 0x38, 0x8e, 0x5b, 0xb0, 0x19, 0x65, 0x6c, 0xdf, 0x1b, 0xd8, 0x1e, 0x51,
	0x97, 0x54, 0x11, 0xcf, 0x0a, 0xf8, 0x20, 0x69, 0x9f, 0x32, 0x12, 0xf6, 0xb3, 0x24, 0xf4, 0x27,
	0x90, 0x8b, 0xb3, 0xfe, 0x35, 0x0c, 0x3e, 0x86, 0xb4, 0x48, 0xf8, 0xd7, 0xb0, 0x45, 0x61, 0x73,
	0x36, 0x6f, 0x35, 0x40, 0x06, 0x3d, 0x24, 0xaf, 0xf6, 0x7c, 0xef, 0xd8, 0x1e, 0xa8, 0xcf, 0x0a,
	0xaa, 0xa1, 0xe6, 0x48, 0x38, 0xbe, 0x35, 0x8b, 0x97, 0xfb, 0xcc, 0x91, 0xb4, 0x9f, 0xbf, 0x3b,
	0xaf, 0x68, 0xef, 0xcf, 0x2b, 0xda, 0x8f, 0xe7, 0x15, 0xed, 0xcd, 0xc7, 0xca, 0xd2, 0xfb, 0x8f,
	0x95, 0xa5, 0x0f, 0x1f, 0x2b, 0x4b, 0xcf, 0xff, 0x38, 0xb0, 0xd9, 0x70, 0xdc, 0xab, 0xf5, 0x7d,
	0xb7, 0xde, 0xf7, 0xa9, 0xeb, 0xd3, 0xba, 0xdd, 0xeb, 0xdf, 0x1e, 0xf8, 0xf5, 0x93, 0x3b, 0x75,
	0xd7, 0xb7, 0xc6, 0x0e, 0xa1, 0xf2, 0xb3, 0xc9, 0xed, 0xf0, 0xbb, 0x49, 0xa3, 0x71, 0x5b, 0x7e,
	0x3a, 0x61, 0xa7, 0x23, 0x42, 0x7b, 0x19, 0xf1, 0x87, 0xe9, 0xce, 0x4f, 0x01, 0x00, 0x00, 0xff,
	0xff, 0x5b, 0x01, 0x07, 0xa7, 0x61, 0x11, 0x00, 0x00,
}

func (m *MmrLeafPartial) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MmrLeafPartial) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MmrLeafPartial) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.NextAuthoritySet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintBeefy(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.ParentHash) > 0 {
		i -= len(m.ParentHash)
		copy(dAtA[i:], m.ParentHash)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.ParentHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ParentNumber != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.ParentNumber))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BeefyAuthoritySet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeefyAuthoritySet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BeefyAuthoritySet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuthorityMerkleRoot) > 0 {
		i -= len(m.AuthorityMerkleRoot)
		copy(dAtA[i:], m.AuthorityMerkleRoot)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.AuthorityMerkleRoot)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Len != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.Len))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClientState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Authority != nil {
		{
			size, err := m.Authority.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.LatestBeefyHeight != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.LatestBeefyHeight))
		i--
		dAtA[i] = 0x20
	}
	if len(m.MmrRootHash) > 0 {
		i -= len(m.MmrRootHash)
		copy(dAtA[i:], m.MmrRootHash)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.MmrRootHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ParachainHeaderProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParachainHeaderProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParachainHeaderProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MmrLeafPartial != nil {
		{
			size, err := m.MmrLeafPartial.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.HeadsProof) > 0 {
		for iNdEx := len(m.HeadsProof) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.HeadsProof[iNdEx])
			copy(dAtA[i:], m.HeadsProof[iNdEx])
			i = encodeVarintBeefy(dAtA, i, uint64(len(m.HeadsProof[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Proofs) > 0 {
		for iNdEx := len(m.Proofs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Proofs[iNdEx])
			copy(dAtA[i:], m.Proofs[iNdEx])
			i = encodeVarintBeefy(dAtA, i, uint64(len(m.Proofs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.LeafIndex != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.LeafIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClientUpdateProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientUpdateProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientUpdateProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuthorityProof) > 0 {
		for iNdEx := len(m.AuthorityProof) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AuthorityProof[iNdEx])
			copy(dAtA[i:], m.AuthorityProof[iNdEx])
			i = encodeVarintBeefy(dAtA, i, uint64(len(m.AuthorityProof[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Signatures[iNdEx])
			copy(dAtA[i:], m.Signatures[iNdEx])
			i = encodeVarintBeefy(dAtA, i, uint64(len(m.Signatures[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MmrRootHash) > 0 {
		i -= len(m.MmrRootHash)
		copy(dAtA[i:], m.MmrRootHash)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.MmrRootHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0x12
	}
	n4, err4 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintBeefy(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Misbehaviour) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Misbehaviour) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Misbehaviour) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Header2 != nil {
		{
			size, err := m.Header2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Header1 != nil {
		{
			size, err := m.Header1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClientUpdateProof != nil {
		{
			size, err := m.ClientUpdateProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	{
		size, err := m.ParachainHeaderProof.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintBeefy(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.TimestampExtrinsic.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintBeefy(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.ExtrinsicProof) > 0 {
		for iNdEx := len(m.ExtrinsicProof) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExtrinsicProof[iNdEx])
			copy(dAtA[i:], m.ExtrinsicProof[iNdEx])
			i = encodeVarintBeefy(dAtA, i, uint64(len(m.ExtrinsicProof[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ParachainHeader != nil {
		{
			size, err := m.ParachainHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Extrinsic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Extrinsic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Extrinsic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Method != nil {
		{
			size, err := m.Method.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Version != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExtrinsicSignatureV4) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtrinsicSignatureV4) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtrinsicSignatureV4) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tip != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.Tip))
		i--
		dAtA[i] = 0x28
	}
	if m.Nonce != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x20
	}
	if m.Era != nil {
		{
			size, err := m.Era.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Signer != nil {
		{
			size, err := m.Signer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MultiAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AsAddress20) > 0 {
		i -= len(m.AsAddress20)
		copy(dAtA[i:], m.AsAddress20)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.AsAddress20)))
		i--
		dAtA[i] = 0x52
	}
	if m.IsAddress20 {
		i--
		if m.IsAddress20 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.AsAddress32) > 0 {
		i -= len(m.AsAddress32)
		copy(dAtA[i:], m.AsAddress32)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.AsAddress32)))
		i--
		dAtA[i] = 0x42
	}
	if m.IsAddress32 {
		i--
		if m.IsAddress32 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.AsRaw) > 0 {
		i -= len(m.AsRaw)
		copy(dAtA[i:], m.AsRaw)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.AsRaw)))
		i--
		dAtA[i] = 0x32
	}
	if m.IsRaw {
		i--
		if m.IsRaw {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.AsIndex != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.AsIndex))
		i--
		dAtA[i] = 0x20
	}
	if m.IsIndex {
		i--
		if m.IsIndex {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.AsID) > 0 {
		i -= len(m.AsID)
		copy(dAtA[i:], m.AsID)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.AsID)))
		i--
		dAtA[i] = 0x12
	}
	if m.IsID {
		i--
		if m.IsID {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MultiSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AsEcdsa) > 0 {
		i -= len(m.AsEcdsa)
		copy(dAtA[i:], m.AsEcdsa)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.AsEcdsa)))
		i--
		dAtA[i] = 0x32
	}
	if m.IsEcdsa {
		i--
		if m.IsEcdsa {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.AsSr25519) > 0 {
		i -= len(m.AsSr25519)
		copy(dAtA[i:], m.AsSr25519)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.AsSr25519)))
		i--
		dAtA[i] = 0x22
	}
	if m.IsSr25519 {
		i--
		if m.IsSr25519 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.AsEd25519) > 0 {
		i -= len(m.AsEd25519)
		copy(dAtA[i:], m.AsEd25519)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.AsEd25519)))
		i--
		dAtA[i] = 0x12
	}
	if m.IsEd25519 {
		i--
		if m.IsEd25519 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExtrinsicEra) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtrinsicEra) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtrinsicEra) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AsMortalEra != nil {
		{
			size, err := m.AsMortalEra.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IsMortalEra {
		i--
		if m.IsMortalEra {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.IsImmortalEra {
		i--
		if m.IsImmortalEra {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MortalEra) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MortalEra) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MortalEra) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Second != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.Second))
		i--
		dAtA[i] = 0x10
	}
	if m.First != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.First))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Call) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Call) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Call) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Args) > 0 {
		i -= len(m.Args)
		copy(dAtA[i:], m.Args)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.Args)))
		i--
		dAtA[i] = 0x12
	}
	if m.CallIndex != nil {
		{
			size, err := m.CallIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CallIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CallIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MethodIndex != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.MethodIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.SectionIndex != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.SectionIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ParachainHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParachainHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParachainHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Digest) > 0 {
		for iNdEx := len(m.Digest) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Digest[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBeefy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ExtrinsicsRoot) > 0 {
		i -= len(m.ExtrinsicsRoot)
		copy(dAtA[i:], m.ExtrinsicsRoot)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.ExtrinsicsRoot)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StateRoot) > 0 {
		i -= len(m.StateRoot)
		copy(dAtA[i:], m.StateRoot)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.StateRoot)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Number != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ParentHash) > 0 {
		i -= len(m.ParentHash)
		copy(dAtA[i:], m.ParentHash)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.ParentHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DigestItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DigestItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AsOther) > 0 {
		i -= len(m.AsOther)
		copy(dAtA[i:], m.AsOther)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.AsOther)))
		i--
		dAtA[i] = 0x62
	}
	if m.IsOther {
		i--
		if m.IsOther {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.AsChangesTrieSignal != nil {
		{
			size, err := m.AsChangesTrieSignal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.IsChangesTrieSignal {
		i--
		if m.IsChangesTrieSignal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.AsSeal != nil {
		{
			size, err := m.AsSeal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.IsSeal {
		i--
		if m.IsSeal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.AsConsensus != nil {
		{
			size, err := m.AsConsensus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.IsConsensus {
		i--
		if m.IsConsensus {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.AsPreRuntime != nil {
		{
			size, err := m.AsPreRuntime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.IsPreRuntime {
		i--
		if m.IsPreRuntime {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.AsChangesTrieRoot) > 0 {
		i -= len(m.AsChangesTrieRoot)
		copy(dAtA[i:], m.AsChangesTrieRoot)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.AsChangesTrieRoot)))
		i--
		dAtA[i] = 0x12
	}
	if m.IsChangesTrieRoot {
		i--
		if m.IsChangesTrieRoot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PreRuntime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreRuntime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PreRuntime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Bytes) > 0 {
		i -= len(m.Bytes)
		copy(dAtA[i:], m.Bytes)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.Bytes)))
		i--
		dAtA[i] = 0x12
	}
	if m.ConsensusEngineID != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.ConsensusEngineID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Consensus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Consensus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Consensus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Bytes) > 0 {
		i -= len(m.Bytes)
		copy(dAtA[i:], m.Bytes)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.Bytes)))
		i--
		dAtA[i] = 0x12
	}
	if m.ConsensusEngineID != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.ConsensusEngineID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Seal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Seal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Seal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Bytes) > 0 {
		i -= len(m.Bytes)
		copy(dAtA[i:], m.Bytes)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.Bytes)))
		i--
		dAtA[i] = 0x12
	}
	if m.ConsensusEngineID != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.ConsensusEngineID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChangesTrieSignal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangesTrieSignal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangesTrieSignal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AsNewConfiguration) > 0 {
		i -= len(m.AsNewConfiguration)
		copy(dAtA[i:], m.AsNewConfiguration)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.AsNewConfiguration)))
		i--
		dAtA[i] = 0x12
	}
	if m.IsNewConfiguration {
		i--
		if m.IsNewConfiguration {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintBeefy(dAtA []byte, offset int, v uint64) int {
	offset -= sovBeefy(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MmrLeafPartial) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovBeefy(uint64(m.Version))
	}
	if m.ParentNumber != 0 {
		n += 1 + sovBeefy(uint64(m.ParentNumber))
	}
	l = len(m.ParentHash)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	l = m.NextAuthoritySet.Size()
	n += 1 + l + sovBeefy(uint64(l))
	return n
}

func (m *BeefyAuthoritySet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBeefy(uint64(m.Id))
	}
	if m.Len != 0 {
		n += 1 + sovBeefy(uint64(m.Len))
	}
	l = len(m.AuthorityMerkleRoot)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *ClientState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	l = len(m.MmrRootHash)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.LatestBeefyHeight != 0 {
		n += 1 + sovBeefy(uint64(m.LatestBeefyHeight))
	}
	if m.Authority != nil {
		l = m.Authority.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *ParachainHeaderProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeafIndex != 0 {
		n += 1 + sovBeefy(uint64(m.LeafIndex))
	}
	if len(m.Proofs) > 0 {
		for _, b := range m.Proofs {
			l = len(b)
			n += 1 + l + sovBeefy(uint64(l))
		}
	}
	if len(m.HeadsProof) > 0 {
		for _, b := range m.HeadsProof {
			l = len(b)
			n += 1 + l + sovBeefy(uint64(l))
		}
	}
	if m.MmrLeafPartial != nil {
		l = m.MmrLeafPartial.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *ClientUpdateProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MmrRootHash)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	if len(m.Signatures) > 0 {
		for _, b := range m.Signatures {
			l = len(b)
			n += 1 + l + sovBeefy(uint64(l))
		}
	}
	if len(m.AuthorityProof) > 0 {
		for _, b := range m.AuthorityProof {
			l = len(b)
			n += 1 + l + sovBeefy(uint64(l))
		}
	}
	return n
}

func (m *ConsensusState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovBeefy(uint64(l))
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *Misbehaviour) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.Header1 != nil {
		l = m.Header1.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.Header2 != nil {
		l = m.Header2.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ParachainHeader != nil {
		l = m.ParachainHeader.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	if len(m.ExtrinsicProof) > 0 {
		for _, b := range m.ExtrinsicProof {
			l = len(b)
			n += 1 + l + sovBeefy(uint64(l))
		}
	}
	l = m.TimestampExtrinsic.Size()
	n += 1 + l + sovBeefy(uint64(l))
	l = m.ParachainHeaderProof.Size()
	n += 1 + l + sovBeefy(uint64(l))
	if m.ClientUpdateProof != nil {
		l = m.ClientUpdateProof.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *Extrinsic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovBeefy(uint64(m.Version))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.Method != nil {
		l = m.Method.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *ExtrinsicSignatureV4) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Signer != nil {
		l = m.Signer.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.Era != nil {
		l = m.Era.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.Nonce != 0 {
		n += 1 + sovBeefy(uint64(m.Nonce))
	}
	if m.Tip != 0 {
		n += 1 + sovBeefy(uint64(m.Tip))
	}
	return n
}

func (m *MultiAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsID {
		n += 2
	}
	l = len(m.AsID)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.IsIndex {
		n += 2
	}
	if m.AsIndex != 0 {
		n += 1 + sovBeefy(uint64(m.AsIndex))
	}
	if m.IsRaw {
		n += 2
	}
	l = len(m.AsRaw)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.IsAddress32 {
		n += 2
	}
	l = len(m.AsAddress32)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.IsAddress20 {
		n += 2
	}
	l = len(m.AsAddress20)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *MultiSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsEd25519 {
		n += 2
	}
	l = len(m.AsEd25519)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.IsSr25519 {
		n += 2
	}
	l = len(m.AsSr25519)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.IsEcdsa {
		n += 2
	}
	l = len(m.AsEcdsa)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *ExtrinsicEra) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsImmortalEra {
		n += 2
	}
	if m.IsMortalEra {
		n += 2
	}
	if m.AsMortalEra != nil {
		l = m.AsMortalEra.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *MortalEra) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.First != 0 {
		n += 1 + sovBeefy(uint64(m.First))
	}
	if m.Second != 0 {
		n += 1 + sovBeefy(uint64(m.Second))
	}
	return n
}

func (m *Call) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallIndex != nil {
		l = m.CallIndex.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	l = len(m.Args)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *CallIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SectionIndex != 0 {
		n += 1 + sovBeefy(uint64(m.SectionIndex))
	}
	if m.MethodIndex != 0 {
		n += 1 + sovBeefy(uint64(m.MethodIndex))
	}
	return n
}

func (m *ParachainHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ParentHash)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.Number != 0 {
		n += 1 + sovBeefy(uint64(m.Number))
	}
	l = len(m.StateRoot)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	l = len(m.ExtrinsicsRoot)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	if len(m.Digest) > 0 {
		for _, e := range m.Digest {
			l = e.Size()
			n += 1 + l + sovBeefy(uint64(l))
		}
	}
	return n
}

func (m *DigestItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsChangesTrieRoot {
		n += 2
	}
	l = len(m.AsChangesTrieRoot)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.IsPreRuntime {
		n += 2
	}
	if m.AsPreRuntime != nil {
		l = m.AsPreRuntime.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.IsConsensus {
		n += 2
	}
	if m.AsConsensus != nil {
		l = m.AsConsensus.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.IsSeal {
		n += 2
	}
	if m.AsSeal != nil {
		l = m.AsSeal.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.IsChangesTrieSignal {
		n += 2
	}
	if m.AsChangesTrieSignal != nil {
		l = m.AsChangesTrieSignal.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.IsOther {
		n += 2
	}
	l = len(m.AsOther)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *PreRuntime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConsensusEngineID != 0 {
		n += 1 + sovBeefy(uint64(m.ConsensusEngineID))
	}
	l = len(m.Bytes)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *Consensus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConsensusEngineID != 0 {
		n += 1 + sovBeefy(uint64(m.ConsensusEngineID))
	}
	l = len(m.Bytes)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *Seal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConsensusEngineID != 0 {
		n += 1 + sovBeefy(uint64(m.ConsensusEngineID))
	}
	l = len(m.Bytes)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *ChangesTrieSignal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsNewConfiguration {
		n += 2
	}
	l = len(m.AsNewConfiguration)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func sovBeefy(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBeefy(x uint64) (n int) {
	return sovBeefy(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MmrLeafPartial) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MmrLeafPartial: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MmrLeafPartial: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentNumber", wireType)
			}
			m.ParentNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentHash = append(m.ParentHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ParentHash == nil {
				m.ParentHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextAuthoritySet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NextAuthoritySet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeefyAuthoritySet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeefyAuthoritySet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeefyAuthoritySet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorityMerkleRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorityMerkleRoot = append(m.AuthorityMerkleRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthorityMerkleRoot == nil {
				m.AuthorityMerkleRoot = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmrRootHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MmrRootHash = append(m.MmrRootHash[:0], dAtA[iNdEx:postIndex]...)
			if m.MmrRootHash == nil {
				m.MmrRootHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestBeefyHeight", wireType)
			}
			m.LatestBeefyHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestBeefyHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Authority == nil {
				m.Authority = &BeefyAuthoritySet{}
			}
			if err := m.Authority.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParachainHeaderProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParachainHeaderProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParachainHeaderProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafIndex", wireType)
			}
			m.LeafIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeafIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proofs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proofs = append(m.Proofs, make([]byte, postIndex-iNdEx))
			copy(m.Proofs[len(m.Proofs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadsProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadsProof = append(m.HeadsProof, make([]byte, postIndex-iNdEx))
			copy(m.HeadsProof[len(m.HeadsProof)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmrLeafPartial", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MmrLeafPartial == nil {
				m.MmrLeafPartial = &MmrLeafPartial{}
			}
			if err := m.MmrLeafPartial.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientUpdateProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientUpdateProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientUpdateProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmrRootHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MmrRootHash = append(m.MmrRootHash[:0], dAtA[iNdEx:postIndex]...)
			if m.MmrRootHash == nil {
				m.MmrRootHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, make([]byte, postIndex-iNdEx))
			copy(m.Signatures[len(m.Signatures)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorityProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorityProof = append(m.AuthorityProof, make([]byte, postIndex-iNdEx))
			copy(m.AuthorityProof[len(m.AuthorityProof)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = append(m.Root[:0], dAtA[iNdEx:postIndex]...)
			if m.Root == nil {
				m.Root = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Misbehaviour) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Misbehaviour: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Misbehaviour: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header1 == nil {
				m.Header1 = &Header{}
			}
			if err := m.Header1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header2 == nil {
				m.Header2 = &Header{}
			}
			if err := m.Header2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParachainHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParachainHeader == nil {
				m.ParachainHeader = &ParachainHeader{}
			}
			if err := m.ParachainHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtrinsicProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtrinsicProof = append(m.ExtrinsicProof, make([]byte, postIndex-iNdEx))
			copy(m.ExtrinsicProof[len(m.ExtrinsicProof)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampExtrinsic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TimestampExtrinsic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParachainHeaderProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ParachainHeaderProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientUpdateProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientUpdateProof == nil {
				m.ClientUpdateProof = &ClientUpdateProof{}
			}
			if err := m.ClientUpdateProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Extrinsic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Extrinsic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Extrinsic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &ExtrinsicSignatureV4{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Method == nil {
				m.Method = &Call{}
			}
			if err := m.Method.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtrinsicSignatureV4) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtrinsicSignatureV4: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtrinsicSignatureV4: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signer == nil {
				m.Signer = &MultiAddress{}
			}
			if err := m.Signer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &MultiSignature{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Era", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Era == nil {
				m.Era = &ExtrinsicEra{}
			}
			if err := m.Era.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tip", wireType)
			}
			m.Tip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tip |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsID", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsID = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsID = append(m.AsID[:0], dAtA[iNdEx:postIndex]...)
			if m.AsID == nil {
				m.AsID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsIndex", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsIndex = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsIndex", wireType)
			}
			m.AsIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AsIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRaw", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRaw = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsRaw", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsRaw = append(m.AsRaw[:0], dAtA[iNdEx:postIndex]...)
			if m.AsRaw == nil {
				m.AsRaw = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAddress32", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAddress32 = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsAddress32", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsAddress32 = append(m.AsAddress32[:0], dAtA[iNdEx:postIndex]...)
			if m.AsAddress32 == nil {
				m.AsAddress32 = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAddress20", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAddress20 = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsAddress20", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsAddress20 = append(m.AsAddress20[:0], dAtA[iNdEx:postIndex]...)
			if m.AsAddress20 == nil {
				m.AsAddress20 = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEd25519", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEd25519 = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsEd25519", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsEd25519 = append(m.AsEd25519[:0], dAtA[iNdEx:postIndex]...)
			if m.AsEd25519 == nil {
				m.AsEd25519 = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSr25519", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSr25519 = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsSr25519", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsSr25519 = append(m.AsSr25519[:0], dAtA[iNdEx:postIndex]...)
			if m.AsSr25519 == nil {
				m.AsSr25519 = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEcdsa", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEcdsa = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsEcdsa", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsEcdsa = append(m.AsEcdsa[:0], dAtA[iNdEx:postIndex]...)
			if m.AsEcdsa == nil {
				m.AsEcdsa = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtrinsicEra) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtrinsicEra: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtrinsicEra: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsImmortalEra", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsImmortalEra = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMortalEra", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMortalEra = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsMortalEra", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AsMortalEra == nil {
				m.AsMortalEra = &MortalEra{}
			}
			if err := m.AsMortalEra.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MortalEra) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MortalEra: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MortalEra: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field First", wireType)
			}
			m.First = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.First |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Second", wireType)
			}
			m.Second = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Second |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Call) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Call: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Call: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallIndex == nil {
				m.CallIndex = &CallIndex{}
			}
			if err := m.CallIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args[:0], dAtA[iNdEx:postIndex]...)
			if m.Args == nil {
				m.Args = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectionIndex", wireType)
			}
			m.SectionIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SectionIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MethodIndex", wireType)
			}
			m.MethodIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MethodIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParachainHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParachainHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParachainHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentHash = append(m.ParentHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ParentHash == nil {
				m.ParentHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateRoot = append(m.StateRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.StateRoot == nil {
				m.StateRoot = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtrinsicsRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtrinsicsRoot = append(m.ExtrinsicsRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.ExtrinsicsRoot == nil {
				m.ExtrinsicsRoot = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Digest = append(m.Digest, &DigestItem{})
			if err := m.Digest[len(m.Digest)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsChangesTrieRoot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsChangesTrieRoot = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsChangesTrieRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsChangesTrieRoot = append(m.AsChangesTrieRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.AsChangesTrieRoot == nil {
				m.AsChangesTrieRoot = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPreRuntime", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPreRuntime = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsPreRuntime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AsPreRuntime == nil {
				m.AsPreRuntime = &PreRuntime{}
			}
			if err := m.AsPreRuntime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConsensus", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConsensus = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsConsensus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AsConsensus == nil {
				m.AsConsensus = &Consensus{}
			}
			if err := m.AsConsensus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSeal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSeal = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsSeal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AsSeal == nil {
				m.AsSeal = &Seal{}
			}
			if err := m.AsSeal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsChangesTrieSignal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsChangesTrieSignal = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsChangesTrieSignal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AsChangesTrieSignal == nil {
				m.AsChangesTrieSignal = &ChangesTrieSignal{}
			}
			if err := m.AsChangesTrieSignal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOther", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOther = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsOther", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsOther = append(m.AsOther[:0], dAtA[iNdEx:postIndex]...)
			if m.AsOther == nil {
				m.AsOther = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreRuntime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreRuntime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreRuntime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusEngineID", wireType)
			}
			m.ConsensusEngineID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConsensusEngineID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bytes = append(m.Bytes[:0], dAtA[iNdEx:postIndex]...)
			if m.Bytes == nil {
				m.Bytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Consensus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Consensus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Consensus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusEngineID", wireType)
			}
			m.ConsensusEngineID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConsensusEngineID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bytes = append(m.Bytes[:0], dAtA[iNdEx:postIndex]...)
			if m.Bytes == nil {
				m.Bytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Seal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Seal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Seal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusEngineID", wireType)
			}
			m.ConsensusEngineID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConsensusEngineID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bytes = append(m.Bytes[:0], dAtA[iNdEx:postIndex]...)
			if m.Bytes == nil {
				m.Bytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangesTrieSignal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangesTrieSignal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangesTrieSignal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNewConfiguration", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNewConfiguration = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsNewConfiguration", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsNewConfiguration = append(m.AsNewConfiguration[:0], dAtA[iNdEx:postIndex]...)
			if m.AsNewConfiguration == nil {
				m.AsNewConfiguration = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBeefy(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBeefy
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBeefy
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBeefy
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBeefy        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBeefy          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBeefy = fmt.Errorf("proto: unexpected end of group")
)
